featureCounts: an efficient general-purpose read Doc-StartBIOINFORMATICS summarization program
Yang Liao 1,2 , Gordon K Smyth 1,3 and Wei Shi 1,2
1

Vol. 00 no. 00 2013 Pages 14

arXiv:1305.3347v1 [q-bio.GN] 15 May 2013

Division of Bioinformatics, The Walter and Eliza Hall Institute of Medical Research, 1G Royal Parade, Parkville, Victoria 3052 Australia, 2 Department of Computing and Information Systems, 3 Department of Mathematics and Statistics, The University of Melbourne, Parkville, VIC 3010, Australia

ABSTRACT Reads generated from the next-generation sequencing technologies are often needed to be assigned to genomic features such as genes, after they were successfully aligned. This process is often called read summarization. Read summarization is required by a number of downstream analyses such as gene expression analysis and histone modification analysis. Current read summarization programs suffer from very high computational cost including large memory consumption and long running time. Here we present featureCounts, a light-weight read summarization program. featureCounts was found to be >15 times faster and use much less memory than the popular methods. It assigns as many, or slightly more reads/fragments than other methods, and it is more powerful in summarizing pairedend read data. It also supports parallel read summarization via multi-threading, enabling even more efficient summarization.

1

INTRODUCTION

Next-generation (next-gen) sequencing technologies are being increasingly adopted in the biomedical reserarch by both large and small laboratories. However, the bioinformatic analyses pose significant challenges for the routine use of these technologies due to the huge and ever increasing volume of the data being generated. One of the very computing-intensive tasks, which has not received enough attention, is the read summarization. The goal of read summarization is to assign mapped reads, or fragments (for paired-end read data), to genomic features such as genes. Read summarization is required by a number of important downstream analyses such as genome-wide gene expression analysis [1, 2] and histone modification analysis [3]. Typically, 10s  100s millions of reads need to be assigned to 10s  100s thousands of genomic features in a next-gen sequencing experiment. The genomic regions, which the reads are aligned to, need to compared with those of genomic features so as to count the number of mapped reads for each feature. Insertions, deletions, exon-exon junctions (from RNA-seq data) and fusions must be considered to achieve an accruate read assignment. Due to the large numbers of reads and features and the complexity in finding the
 to

overlaps between reads and features, the computational cost of read summarization could be as high as that of read alignment. The R package GenomicRanges, developed by the core team of the Bioconductor project [4], includes functions for checking overlaps between reads and features and assigning reads to their overlapping features. Although C functions (written in the C programming language) have been developed to try to efficiently detect overlaps between reads and features in this package, it still consumes a large amount of computing resources in the read summarization due to the very low efficiency of the R programming language. In particular, it has an extremely high memory usage. Htseq-count is another popular read summarization program [5], which is mainly written in the Python programming language. Similar to R, Python is an interpreted language and is inefficient in this kind of operation. Furthermore, GenomicRanges and htseqcount do not have facilities to check the validity of the paired-end read distance, limiting their use in summarizing paired-end read data. They also do not suppport multi-threaded running, failing to take advantage of the multi-core architecture of the computers. This makes them almost impractical for summarizing large datasets. Here we present a light-weight read summarization program called featureCounts, which is developed entirely using the very efficient C programming language. It uses a two-level indexing scheme to speed up the summarization and it supports multithreaded running. It is a general-purpose summarization program that can process reads generated by both genomic DNA sequencing and RNA sequencing technologies and summarize them to any type of genomic features.

2 2.1

MATERIALS AND METHODS Datasets and software programs

whom correspondence should be addressed

Three datasets were used in the evaluation, including two datasets generated by the 1000Genomes project (ERR161544 and SRR070481) and an RNA-seq dataset generated by the Sequencing Quality Control (SEQC) project, which is the third stage of the MAQC project [6]. ERR161544 is a whole genome sequencing (WGS) dataset, including 74 million pairs of 100bp reads. SRR070481 is a whole exome sequencing (WES) dataset, including

c Oxford University Press 2005.

1

Liao et al

Table 1. Comparing alternative methods for summarizing sequencing reads. The second column gives the number of reads assigned to RefSeq genes. The SEQC dataset was treated as single-end reads and then summarized by alternative methods to give the results included in this column. Columns 3-5 give the number of fragments assigned to RefSeq genes by alternative methods. Running time and memory usage were measured using the dataset SRR070481. The running time for featureCounts was measured using one thread.

Methods featureCounts htseq-count GenomicRanges

SEQC-SE 8,465,678 8,465,348 8,465,678

SEQC 4,796,948 4,769,913 3,942,439

ERR161544 2,630,174 2,617,547 2,508,248

SRR070481 19,756,287 19,687,670 19,034,816

Time (Mins) 3.3 87.0 55.1

Memory (MB) 39 101 14,200

27 million pairs of 100bp reads. The SEQC dataset includes 6.8 million pairs of 101bp reads. The SEQC dataset was aligned to the human genome (GRCh37) using the Subjunc aligner [7], which is a splice-aware aligner. The other two datasets were aligned to GRCh37 using the Subread aligner [7]. Three summarization programs were included for comparison, including GenomicRanges (v1.12.1), htseq-count (v0.5.4p1) and featureCounts v1.3.3. The summarizeOverlaps function included in the GenomicRanges package was used for its summarization. Both htseq-count and summarizeOverlaps were run with the `Union' mode. featureCounts is part of the Subread software package, which includes a suite of programs for processing next-gen sequencing data (http://subread.sourceforge.net). featureCounts was run with a setting similar to that of htseq-count.

feature is called when there is at least 1-base overlap found between the read and the feature. featureCounts can also perform read summarization at the metafeature level (this is its defaut operation). A meta-feature is a group of features which have the same gene identifier (eg. specifed via the `gene id' attribute of a GTF annotation). When summarizing at the meta-feature level, a read will be only counted once for the meta-feature overlapping with it even the read is found to overlap with more than one feature belonging to this meta-feature. This is particularly useful for summarizing RNA-seq reads to genes, because any RNA-seq read should be counted only once for its overlapping gene even it overlaps with multiple exons of that gene.

2.2

Feature indexing and read counting 3 3.1 RESULTS Summarizing single-end read data

The featureCounts program builds a two-level index to speed up the read summarization. After reading in the annotation file (the default annotation format is the Gene Transfer Format (GTF)), the program firstly sorts the features (each row in the annotation file is taken as a feature) by their chromosomal names and chromosomal start locations, and then builds a chromosome level index. This index enables fast retrieval of features residing on the same chromosome. It then builds a within-chromosome index by grouping features into blocks (Fig. 1). This second-level index enables featureCounts to quicky traverse to the genomic region where features overlapping with a query read can be found. Candidate blocks are identified by comparing the genomic span of each block with the target region the read is mapped to, and the overlapping features are detected within these blocks by a precise interval comparison. An overlapping

read chromosome block 1 block2 block 3

block-index

bl1ck

bl2ck

bl3ck

bl4ck

Fig. 1: Indexing blocks of features and identifying features overlapping with the query read.

The three datasets used for evaluation all include paired-end reads (see MATERIALS AND METHODS). To assess the performance of these programs in summarizing single-end reads, we treated the SEQC data as a single-end read dataset and then re-aligned it using the Subjunc aligner. The resulting mapping results were then used for single-end read summarization. The annotation used in the summarization was the NCBI human RefSeq annotation (build 37.2), which includes 25,702 genes (225,071 exons). Gene-level (ie. meta-feature level) read summarization was performed in this evaluation. Table 1 shows the evaluation results. For single-end reads, featureCounts and GenomicRanges assigned exactly the same number of reads to genes (the `RNA-seq(SE)' column). Every read was found to be assigned to the same gene by these two programs. Therefore featureCounts and GenomicRanges yielded identical read summarization results. We observed a small difference in the summarization result between featureCounts and htseq-count (Fig. 2(a)). We found the reason for this is because htseqcount takes the right-most position of each feature as an open position, ie. this position was excluded by htseq-count when it checked the overlap between reads and features. The annotation we used for summarization is the GTF format in which the the right-most position of each feature is inclusive according to the GTF format specification (https://genome.ucsc.edu/ FAQ/FAQformat.html#format4).

2

featureCounts

featureCounts

htseq-count

691

8464987

361

(a) Single-end
featureCounts htseq-count

27102

4769846

67

(b) Paired-end

Fig. 2: The concordance and difference in the summarization results between featureCount and htseq-count. (a) Reads commonly and exclusively assigned by the two methods and (b)Fragments commonly and exclusively assigned by the two methods. The reads and fragments, which were commonly assigned by the two methods, were found to be always assigned to the same genes. The SEQC data are used here.

found to overlap with both ends of the fragment and all the others overlapped with only one end, this fragment will be assigned by featureCounts and assigned to the gene that overlapped with both ends. But this read will not be assigned by htseq-count. A gene overlapping with both ends of the fragment should be more likely to be the real target than those genes overlapping with only one end of the fragment, and that is the reason why we tried to count the fragments which have both their ends overlapping with a gene. Nonetheless, a high concordance in fragment assignment results was observed between featureCounts and htseq-count (Fig. 2(b)). Not that featureCounts also provides an option to allows users to specify whether both ends from the same fragment are required to be mapped and an option to check the validity of the pairedend read distance when summarizing paired-end reads. Neither GenomicRanges nor htseq-count allows users to check the validity of the paired-end distance and htseq-check does not allow users to specify if the two reads from the same fragment are required to be both mapped. featureCounts also allows users to specify if they would like count chimeric fragments (the two ends from the same fragment was mapped to different chromosomes). With these flexibilities, featureCounts gives users a lot more power in controlling how their paired-end data can be best summarized.

3.3

Speed and memory usage

3.2

Summarizing paired-end read data

In this section, we used two 1000Genomes datasets and a SEQC dataset to compare the alternative methods for summarizing pairedend read datasets. These datasets all include paired-end reads. Similar to the comparisons of summarizing single-end reads in the last section, gene-level summarization was performed and NCBI RefSeq annotation was used here. In this evaluation, we assigned the fragments (two reads were sequenced from each fragment), instead of reads, to genes. Note that htseq-count can only count fragments when paired-end data are provided, whereas featureCounts and GenomicRanges can count either fragments or reads when summaring paired-end read data. GenomicRanges was found to assign less fragments than featureCounts and htseq-count, and featureCounts assigned slightly more fragments than htseq-count, in the summarization of all three datasets (columns 3-5 of Table 1). GenomicRanges and htseqcount were run under the same mode (`Union' mode), but the reason why GenomicRanges counted less fragments than htseqcount is because GenomicRanges requires both ends from the same fragment to be mapped in the counting whereas htseq-count does not have such a requirement. The `Union' mode is the default summarization mode used by both htseq-count and GenomicRanges and this mode enables them to count more fragments than using the other two modes they support (`IntersectionStrict' and `IntersectionNotEmpty' modes). featureCounts was run with a setting similar to that of htseqcount. However because it resolved some fragments classified as `ambiguous' by htseq-count, it counted slightly more fragments than htseq-count (columns 3-5 of Table 1). If a fragment was found to overlap with more than one gene, but only one of them was

The above results showed that featureCounts can assign more reads/fragments and is more powerful than the competing methods. However, the most spectacular improvement featureCounts has made over other methods is on the computational efficiency. featureCounts was found to be >15 times faster than GenomicRanges and >25 times faster than htseq-count. It also has a very small memory footprint, much smaller than the size of memory used by GenomicRanges and htseq-count (Table 1). The superior computational efficiency of featureCounts is mainly due to its poweful two-level indexing scheme and the highly efficient implementation using the C programming language. Furthermore, featureCounts can be run with multiple threads/CPUs to further speed up the summarization, making it have a spectacular efficiency in summarizing large read datasets.

4

DISCUSSION AND CONCLUSION

To the best of our knowledge, this is the first study that compares alternative methods for summarizing next-gen sequencing reads. Our results showed a high concordance between different methods, although noticeable differences were observed for the summarization of paired-end read data. The featureCounts program was found to be able to assign more reads or fragments than GenomicRanges and htseq-count, and it is particularly poweful in summarizing paired-end read data. Finally, featureCounts was found to be far more computationally efficient than other methods, making it suitable for being routinely used for summarizing nextgen sequencing read data.

5

ACKNOWLEDGEMENTS

We thank Leming Shi and Charles Wang for providing the SEQC pilot data.

3

Liao et al

6

FUNDING

This work was supported by a Project Grant (1023454) and a Fellowship (to GKS) from the Australian National Health and Medical Research Council (NHMRC), and was made possible through Victorian State Government Operational Infrastructure Support and Australian Government NHMRC IRIIS.

REFERENCES
[1]DJ McCarthy, Y Chen, and GK Smyth. Differential expression analysis of multifactor RNA-seq experiments with respect to biological variation. Nucleic Acids Res, 40:428897, 2012. [2]CW Law, Y Chen, W Shi, and GK Smyth. Voom! Precision weights unlock linear model analysis tools for RNA-Seq read counts. 2013. submitted.

[3]B Pal, T Bouras, W Shi, F Vaillant, J Sheridan, N Fu, K Breslin, K Jiang, ME Ritchie, M Young, GJ Lindeman, GK Smyth, and JE Visvader. Ezh2 coordinates global changes in the mammary epigenome induced by hormonal cues and controls mammary progenitor activity. Cell Rep, 3:41126, 2013. [4]RC Gentleman, VJ Carey, DM Bates, B Bolstad, M Dettling, S Dudoit, B Ellis, L Gautier, Y Ge, and J et al. Gentry. Bioconductor: open software development for computational biology and bioinformatics. Genome Biol, 5:R80, 2004. [5]Simon A. Htseq: Analysing high-throughput sequencing data with python. http: //www-huber.embl.de/users/anders/HTSeq/doc/count.html. accessed 9-May-2013. [6]L Shi, LH Reid, WD Jones, R Shippy, JA Warrington, SC Baker, PJ Collins, F de Longueville, ES et al. Kawasaki, and MAQC Consortium. The Microarray Quality Control (MAQC) project shows inter- and intraplatform reproducibility of gene expression measurements. Nat Biotechnol, 24:115161, 2006. [7]Liao Y, Smyth GK, and Shi W. The subread aligner: fast, accurate and scalable read mapping by seed-and-vote. Nucleic Acids Research, 41, 2013. Advance Access, April 4 [Epub ahead of print].

4


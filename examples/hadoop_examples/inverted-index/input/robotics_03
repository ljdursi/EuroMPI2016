Finding a Needle in an Exponential Haystack: Discrete RRT for Exploration of Implicit Roadmaps in Multi-Robot Motion Planning
Kiril Solovey, Oren Salzman and Dan Halperin
Balvatnic School of Computer Science, Tel-Aviv University, Israel
Abstract--We present a framework for multi-robot motion planning which incorporates an implicit representation of a roadmap with a novel approach for pathfinding in geometrically embedded graphs. Our pathfinding algorithm, which we call discrete-RRT (dRRT), is an adaption of the celebrated RRT algorithm, for the discrete case of a graph. By rapidly exploring the high-dimensional configuration space represented by the implicit roadmap, dRRT is able to reach subproblems where minimal coordination between the robots is required. Integrating the implicit representation of the roadmap, the dRRT algorithm, and techniques that are tailored for such subproblems on the implicit roadmap allows us to solve multi-robot problems while exploring only a small portion of the configuration space. We believe that our approach, which is probabilistically complete, is the state-of-the-art for scenarios that require tight coupling of multiple robots. We demonstrate this experimentally on various challenging scenarios where our algorithm is faster by a factor of at least fifteen when compared to existing algorithms that we are aware of.

I. I NTRODUCTION Multi-robot motion planning is a fundamental problem in robotics and has been extensively studied in the last three decades. In this problem we are concerned with finding paths for a group of robots, operating in the same workspace, moving from start to target positions while avoiding collisions with obstacles as well as with each other. We consider the continuous formulation of the problem, where the robots and obstacles are geometric entities and the robots operate in a configuration space, e.g., Rd (as opposed to the discrete variant, sometimes called the pebble motion problem, where the robots move on a graph). A. Previous Work we assume some familiarity with the basic terminology of motion planning. For background on motion planning, see, e.g., [5, 12]. Initial work on motion planning aimed to develop complete algorithms, which guarantee to find a solution when one exists or report that none exists otherwise. Such algorithms for the multi-robot case exist [18] yet are exponential in the number of robots. The exponential running time, which may be unavoidable [8] can be attributed to the high number of degrees of freedom (dof )--the sum of the dofs of the individual robots. For the case of two or three robots, the number of dofs may be slightly reduced [2], by constructing a path where the robots move while maintaining contact with each other. A more general approach to reduce the number of dofs was

suggested by van den Berg et al. [23]. In their work, the motion-planning problem is decomposed into subproblems, each consisting of a subset of robots, where every subproblem can be solved separately and the results can be combined into a solution for the original problem. Decoupled planners are an alternative to complete planners trading completeness for efficiency. Typically, decoupled planners solve separate problems for individual robots and combine the individual solutions into a global solution (see, e.g., [14, 22]). Although efficient in some cases, the approach usually works only for a restricted set of problems. The introduction of sampling-based algorithms such as the Probabilistic Roadmap Method (PRM) [10] and the RapidlyExploring Random Tree (RRT) [11] and their many variants, had a significant impact on the field of motion planning. These algorithms gained an increasing popularity due to their efficiency, simplicity and applicability to a wide range of problems. Sampling-based algorithms attempt to capture the connectivity of the configuration space by sampling collisionfree configurations and constructing a roadmap--a graph data structure where the free configurations are vertices and the edges represent collision-free paths between nearby configurations. Although these algorithms are not complete, most of them are probabilistically complete, that is, they are guaranteed to find a solution, if one exists, given a sufficient amount of time. Recently, Karaman and Frazolli [9] introduced several variants of these algorithms such that, with high probability they produce paths that are optimal with respect to some quality measure. For more information on sampling-based algorithms see, e.g., [12]. Sampling-based algorithms can be easily extended to the multi-robot case by considering the fleet of robots as one composite robot [17]. Such a naive approach suffers from inefficiency as it overlooks aspects that are unique to the multirobot problem. More tailor-made sampling-based techniques have been proposed for the multi-robot case [7, 20]. Notewor thy is the work of Svestka and Overmars [24] who suggested to construct a composite roadmap which is a Cartesian product of roadmaps of the individual robots. Due to the exponential nature of the resulting roadmap, this technique is only applicable to problems that involve a modest number of robots. A recent work by Wagner et al. [26] suggests that the composite roadmap does not necessarily have to be explicitly represented. Instead, they maintain an implicitly represented composite

arXiv:1305.2889v1 [cs.RO] 13 May 2013

(a)

(b)

(c)

(d)

Fig. 1. Highly-coupled environments used for the experiments. The robots' start and target positions are depicted by fully-colored disks and annuli, respectively, unless stated otherwise. (a) The red and green robots (on the top) need to change positions with the purple and orange robots (on the bottom), (b) the robots need to interchange their order by entering the narrow corridor, (c) opposite robots need to interchange positions ,(d) Ten randomly placed, relatively large robots; see variations on this scene in the sequel.

roadmap, and apply their M* algorithm [25] to efficiently retrieve paths, while minimizing the explored portion of the roadmap. The resulting technique is able to cope with a large number of robots, for certain types of scenarios. A detailed description of these two these two approaches is provided in Section II below. B. Contribution In this paper we present a probabilistically complete sampling-based algorithm for the multi-robot motion-planning problem. Similar to the approach of Wagner et al. [26], we maintain an implicit representation of the composite roadmap, but we propose an alternative highly efficient technique for pathfinding in the implicitly represented roadmap, which can cope with scenarios that involve tight coupling of the robots. Our new approach, which we call dRRT, is an adaptation of the celebrated RRT algorithm [11] for the discrete case of a graph, embedded in Euclidean space. dRRT traverses a composite roadmap that may have exponentially many neighbors (exponential in the number of robots that need to be coordinated). The efficient traversal is achieved by retrieving only partial information of the explored roadmap. Specifically, it considers a single neighbor of a visited vertex at each step. The dRRT algorithm rapidly explores the configuration space represented by the implicit graph. It is able to reach subproblems where minimal coordination between the robots is required. Integrating the implicit representation of the roadmap, the dRRT algorithm, and techniques that are tailored for such subproblems on the implicit roadmap allows us to solve multi-robot problems while exploring only a small portion of the configuration space. We mention that we are not the first to consider RRTs in discrete domains. Branicky et al. [4] applied the RRT algorithm to a discrete graph. However, a key difference between their work and ours is that we assume that the graph is geometrically embedded, hence we use random points as samples while they use nodes of the graph as samples. In addition, their technique requires that all the neighbors of a visited vertex will be considered--a costly operation in our setting, as mentioned above. We demonstrate the capabilities of our technique on the setting of disk robots moving amidst polygonal obstacles in the plane. This is shown experimentally on various challenging

scenarios where our algorithm is faster by a factor of at least fifteen when compared to existing algorithms that we are aware of. We show that we manage to solve problems of up to 20 dofs for highly coupled scenarios (Figure 1). The organization of this paper is as follows. In Section II we elaborate on two sampling-based multi-robot motion planning algorithms, namely the composite roadmap approach by  Svestka and Overmars [24] and the work on subdimensional expansion and M* by Wagner et al. [25, 26]. In Section III we introduce the dRRT algorithm. For clarity of exposition, we first describe it as a general pathfinding algorithm for geometrically embedded graphs and only in the following section (Section IV) we utilize dRRT in the setting of multirobot motion-planning problem for the exploration of implicitly represented composite roadmaps. We show in Section V experimental results for the algorithm on different scenarios and conclude the paper in Section VI with possible future research directions. II. C OMPOSITE ROADMAPS FOR M ULTI -ROBOT M OTION P LANNING This section details the composite roadmap approach for  multi-robot motion planning that was introduced by Svestka and Overmars [24], where a Cartesian product of PRM roadmaps of individual robots is considered as a means of devising a roadmap for the entire fleet of robots. However, since they consider an explicit construction of this roadmap, their technique is applicable to scenarios that involve only a small number of robots. To overcome this barrier, Wagner et al. suggests [25, 26] to represent the roadmap implicitly. In their work on subdimensional expansion they describe a novel algorithm to find paths on this implicit data structure. The composite roadmap will be used in our method as well and we therefore describe it in detail in the next subsection. In the following subsection we review the subdimensional expansion framwork. A. Composite Roadmaps Let r1 , . . . , rm be m robots operating in a workspace W . Every robot ri is assigned start and target configurations si , ti and the goal is to find paths for every robot from start to target, while avoiding collision with obstacles as well as with the other robots.

For every i let Gi = (Vi , Ei ) be a PRM roadmap for the robot ri , where |Vi |= n, and let k denote the maximal degree of a vertex in any Gi . In addition, assume that si , ti  Vi , and si , ti reside in the same connected component of Gi . Given such a collection of roadmaps G1 , . . . , Gm a composite roadmap can be defined in two different ways-- one is the result of a Cartesian product of the individual roadmaps while in the other a tensor product is used. The two methods [24, 26] mentioned above utilize different types of composite roadmaps, yet both refer to it as a result of a Cartesian product. This might lead to confusion, and we wish to clarify the difference between the two products [1]. The composite roadmap G = (V, E) is defined as follows. The vertices V represent all combinations of vertices of the m single-robot roadmaps that represent collision-free placements of the m robots. Formally, a set of m robot configurations C = (v1 , . . . , vm ) is a vertex of G if for every i, vi  Vi , and in addition, when every robot ri is placed in vi the robots are collision-free. The Cartesian and tensor products differ in the type of edges in the resulting roadmap. If the Cartesian product is used, then (C, C )  E, where C = (v1 , . . . , vm ), C  (v1 , . . . , vm ), if there exists i such that (vi , vi )  Ei , for every j = i it holds that vj = vj , and the robots do not collide while ri moves from vi to vi . A tensor product generates many more edges. Specifically, (C, C )	E if (vi , vi )  Ei for every i, and the robots remain collision-free while moving on the respective single-graph edges. 1 Remark. Throughout this work, unless stated otherwise, we refer to the tensor product composite roadmap. Note that by the definition of Gi and G it holds that S, T	V, where S = (s1 , . . . , sm ), T = (t1 , . . . , tm ). The following observation immediately follows (for both product types). Observation 1. Let C1 , . . . , Ch be a sequence of h vertices of G such that S = C1 , T = Ch and for every two consecutive vertices (Ci , Ci+1 )  E. Then, there exists a path for the robots from S to T . Thus, given a composite roadmap G, it is left to find such a path between S and T . Unfortunately, standard pathfinding techniques, which require the full representation of the graph, cannot be used since the number of vertices of G alone may reach O(nm ). One may consider the A* algorithm [16], or its variants, as appropriate for the task, since it may not need to traverse all the vertices of graph. A central property of A* is that it needs to consider all the neighbors of a visited vertex in order to guarantee that it will find a path eventually. Alas, in our setting, this turns out to be a significant drawback, since the number of neighbors of every vertex is O(k m ) (when the tensor product is used).

B. Subdimensional Expansion and M* Wagner et al. propose a general strategy called subdimensional expansion [26] for motion planning of multiple robots. Their approach acknowledges the fact that only the motion of some of the robots has to be coupled in typical scenarios. Thus, planning in the joint configuration space is only required for robots that have to be coupled, while the motion of the rest of the robots can be planned individually. As a result, their method dynamically explores low-dimensional search spaces embedded in the full configuration space, instead of considering the joint high-dimensional configuration space. This concept comes into practice when they apply their M* algorithm [25] for pathfinding on the composite roadmap. M* can be described as a variant of the A* algorithm that exploits the fact that the explored roadmap is a result of a tensor product of individual-robot roadmaps. Recall that A* maintains an open list of vertices, which are candidates for expansion towards the target. At each step a vertex is chosen for expansion according to some heuristic function and all the vertex's neighbors are inserted into the open list. M* behaves similarly except that at a vertex chosen for expansion, a limited set of neighbors that is inserted into the open list. The edges in this set describe (i) the individual optimal2 motion for robots that do not require coordination (ii) all possible motions for robots whose motion has to be coupled. This technique is highly effective for scenarios with a low degree of coupling, and can cope with large fleets of robots in such setting. However, when the degree of coupling increases, this algorithm suffers from poor running times, as it has to consider many neighbors of a visited vertex. Specifically, the number of neighbors of a vertex is exponential in the degree of coupling. As an example, for a scenario with k = 15 (recall that k is the maximal degree of a vertex in a single-robot roadmap) and a degree of coupling equal to five, a single vertex considered by M* in this setting may have up to 155  220 neighbors. Thus, M* becomes intractable when the degree of coupling exceeds five. Notice that this occurs when the tensor product is considered, while in the Cartesian case, the degree of each vertex is much smaller (O(km)). Although Wagner et al. did not discuss the use of a Cartesian composite roadmap we demonstrate in Section V that M* exhibits very large running times for this case as well. III. D ISCRETE RRT We describe a technique which we call discrete RRT (dRRT) for pathfinding in implicit graphs that are embedded in a Euclidean space. For clarity of exposition, we first describe dRRT without the technicalities related to motion planning. We add these details in the subsequent section. As the name suggests, dRRT is an adaptation of the RRT algorithm [11]
2 Wagner et al. define the cost function for the multi-robot case as the sum of the individual robots' path lengths.

1 There is wide consensus on the term tensor product as defined here, and less so on the term Cartesian product. As the latter has already been used before in the context of motion planning, we will keep using it here as well.

qrand

qrand

qrand qnew

qrand qnew qnear

qnear

qnear

T
(a) (b) (c) (d) Fig. 2. An illustration of the expansion step of dRRT. The tree T is drawn with black vertices and edges, while the gray elements represent the unexplored portion of the graph G. (a) A random point qrand (purple) is drawn uniformly from [0, 1]d . (b) The vertex qnear of T that is the Euclidean nearest neighbor of qrand is extracted. (c) The neighbor qnew of qnear , such that its direction from qnear is the closest to the direction of qrand from qnear , is identified. (d) The new vertex and edge are added to T . Additional information for Theorem 2 : In (b) the Voronoi diagram of the vertices of T is depicted in blue, and the Voronoi cell of qnear ,Vor(qnear ), is filled with light blue. In (c) the Voronoi diagram of the rays that leave qnear and pass through its neighbors is depicted in red, and the Voronoi cell of (qnear , qnew ), Vor (qnear , qnew ), is filled with pink. The purple region in (d) represents Vor(qnear )  Vor (qnear , qnew ).

for the purpose of exploring discrete geometrically-embedded graphs, instead of a continuous space.3 Since the graph serves as an approximation of some relevant portion of the Euclidean space, traversal of the graph can be viewed as a process of exploring the subspace. The dRRT algorithm rapidly explores the graph by biasing the search towards vertices embedded in unexplored regions of the space. Viewed alternatively, it refrains from visiting unexplored vertices that are in the vicinity of explored vertices. Let G = (V, E ) be a graph where every v  V is embedded in a point in Euclidean space Rd and every edge (v, v )  E is a curve that connects the points. Given two vertices s, t  V the goal of the dRRT algorithm is to find a path in G from s to t. For simplicity, we assume that the graph is embedded in [0, 1]d . Similarly to its continuous counterpart, dRRT grows two trees that are rooted in s and t and tries to connect them to form a path from s to t. As in RRT, the growth of the trees is achieved by extending them towards random samples in [0, 1]d , although in our case vertices and edges that are added to the trees are taken from G, and we do not generate new vertices and edges along the way. As G is represented implicitly, the algorithm uses an oracle to retrieve information regarding neighbors of visited vertices. We first describe this oracle and then proceed with a full description of the dRRT algorithm. Finally, we show that this technique is probabilistically complete. A. Oracle to Query the Implicit Graph In order to retrieve partial information regarding the neighbors of visited vertices, dRRT consults an oracle described below. We start with several basic definitions. Given two points v, v  [0, 1]d , denote by (v, v ) the the ray that starts in v and goes through v . Given three points v, v , v  [0, 1]d , denote by v (v , v ) the (smaller) angle between (v, v ) and (v, v ).
3 To be precise, our algorithm is based on the bidirectional RRT variant [11], namely growing two trees from the start and target configurations.

Definition 1 (Direction Oracle). Given a vertex v  V , and a point u  [0, 1]d the direction oracle OD returns argmin {
v v (u, v

)|(v, v )  E } .

In other words, the direction oracle returns the neighbor v of v such that the direction from v to v is closest to the direction from v to u. B. Description of dRRT At a high level, dRRT proceeds just like RRT, and we repeat it here for completeness. The dRRT algorithm (Algorithm 1) grows two trees T0 , T1 that are subgraphs of G, where the former is rooted in s and the latter in t (line 1). The growth of the trees (line 3) is achieved by an expansion towards random samples. Additionally, an attempt to connect the two trees is made (line 4). The algorithm terminates when this operation succeeds and a solution path is generated (line 6), otherwise the algorithm repeats line 2. Expansion of the trees is performed by the EXPAND operation (Algorithm 2) which performs N iterations that consist of the following steps. Given a point qrand uniformly sampled from [0, 1]d , a node qnear in one of the trees that is the closest to the sample (in Euclidean distance), is selected (line 3) and extended towards the sample by locating the vertex qnew  V , that is the neighbor of qnear in G in the direction of qrand (by OD ). Once qnew is found (line 4), it is added to the tree (line 6) with the edge (qnear , qnew ) (line 7). See an illustration of this process in Figure 2. This is already different from the standard RRT as we cannot necessarily proceed exactly in the direction of the random point. After the expansion step, the algorithm tries to connect the trees using the CONNECT TREES operation (Algorithm 3). Pairs of vertices from the two trees, q0  T0 , q1  T1 , that are candidates for connection are found by sampling random points (line 2) and finding their (Euclidean) nearest neighbors in the two trees (lines 3, 4). Given such a pair q0 , q1 , an attempt is made to connect them using the method LOCAL CONNECTOR (line 5) which is a crucial

part of the dRRT algorithm (see Subsection III-C). This process is repeated P times. Finally, given a path  from q0 to q1 , which connects the two trees, the final method RETRIEVE PATH (Algorithm 1, line 6) returns the concatenation of the path from s to q0 , with  and with the path from q1 to t, as in the standard RRT algorithm. C. Local Connector We show in the following subsection that it is possible that the two trees will find a common vertex during the EXPAND stage, and therefore an application of LOCAL CONNECTOR will not be necessary. However, in practice this is unlikely to occur within a short time frame, especially when G is large. Thus, we employ a heavy-duty technique, which given two nearby vertices q0 , q1 (where q0  T0 , q1  T1 ), tries to find a path between them. We mention that it is common to assume in sampling-based algorithms that connecting nearby samples will require less effort than solving the initial problem and here we make a similar assumption. We also assume that a local connector is effective only on restricted pathfinding problems, thus in the general case it cannot be applied directly on s, t, as it may be highly costly (unless the problem is easy). To avoid a situation where too much effort is put into finding a path between q0 and q1 that cannot be easily connected by LOCAL CONNECTOR, the search is terminated after a predefined criterion has been met. As an example for a generic local connector the A* algorithm can be considered. A natural termination criterion for this example is a bound on the number vertices we allow A* to consider. This generic local connector can be used by the general dRRT algorithm, when no additional property of the explored graph G is known. In the following section, where the adaptation of the dRRT algorithm for the multirobot problem is discussed, this component will be modified to take advantage of the fact that G is a composite roadmap. Algorithm 1 dRRT PLANNER (s, t) 1: T0 .init(s); T1 .init(t) 2: loop 3: EXPAND(T0 ); EXPAND(T1 ) 4:   CONNECT TREES(T0 , T1 ) 5: if not empty() then 6: return RETRIEVE PATH (T0 , T1 , ) Algorithm 2 EXPAND (T ) 1: for i = 1  N do 2: qrand  RANDOM SAMPLE() 3: qnear  NEAREST NEIGHBOR(T , qrand ) 4: qnew  OD (qnear , qrand ) 5: if qnew  T then 6: T .add vertex(qnew ) 7: T .add edge(qnear , qnew )

Algorithm 3 CONNECT TREES (T0 , T1 ) 1: for i = 1  P do 2: qrand  RANDOM SAMPLE() 3: q0  NEAREST NEIGHBOR(T0 , qrand ) 4: q1  NEAREST NEIGHBOR(T1 , qrand ) 5:	 LOCAL CONNECTOR(q0 , q1 ) 6: if not empty() then 7: return  8: return	D. Probabilistic Completeness of dRRT Recall that an algorithm is probabilistically complete if it finds a solution given a sufficient amount of time (when such a solution exists). For simplicity, we show that dRRT possesses a stronger property and with high probability will eventually reveal all the vertices of the traversed graph, assuming this graph is connected. The proof relies on the assumption that the vertices of the traversed graph G are in general position, that is, every pair of distinct vertices are embedded in two distinct points in Rd , and for every triplet of distinct vertices the points in which they are embedded are non-collinear. This issue will be addressed in the following section, where we consider the application of dRRT on a specific type of graphs. The proof does not need to take into consideration the local connector and we assume for simplicity that dRRT grows only the first tree T0 , while the other stays static throughout the run. Theorem 2. Let G = (V, E ) be a connected graph embedded in [0, 1]d where the vertices are in general position. Then ,with high probability, every vertex of G will be revealed by the dRRT algorithm, given a sufficient amount of time. Proof: Denote by U0 the set of vertices of T0 after the completion of an iteration of the algorithm. Let v   V \ U0 be an unvisited vertex such that there exists (v, v  )  E , where v  U0 . We wish to show that the probability that T0 will be expanded on the edge (v, v  ), and thus v  will be added to U0 , is bounded away from zero. For simplicity we assume that there exists a single vertex v  U0 that has an edge to v  . Denote by Vor(v ) the Voronoi cell [6] of the site v , in the Euclidean (standard) Voronoi diagram of point sites, where the sites are the vertices of U0 . In addition, denote by Vor (v, v  ) the Voronoi cell of (v, v  ), in a Voronoi diagram of the ray sites (v, v  ), (v, u1 ), . . . , (v, uj ), where u1 , . . . , uj are the neighbors of v in T0 , not including v  . See Figure 2 for an illustration in R2 . Notice that in order to extend T0 from v to v  the random sample qrand in EXPAND (Algorithm 2) has to fall inside Vor(v )  Vor (v, v  ). Thus, in order to guarantee that v  will be added to T0 , with non-zero probability, we show that the shared region between these two cells has non-zero measure, namely |Vor(v )	Vor (v, v  )|> 0, where || denotes the volume of . By the general position assumption we can deduce that |Vor(v )|> 0 and |Vor (v, v  )|> 0. In addition, the intersection

between the two cells is clearly non-empty: There is a ball with radius r > 0 whose center is v and is completely contained in Vor(v ); similarly, there is a cone of solid angle  > 0 with apex at v fully contained in Vor (v, v  ). Hence, it holds that |Vor(v )  Vor (v, v  )|> 0, otherwise v and v  are embedded in the same point. IV. A PPLYING D RRT TO C OMPOSITE ROADMAPS We discuss the adaptation of the dRRT algorithm for pathfinding in a composite (tensor) roadmap G, which is embedded in the joint configuration space of the m robots. Specifically, we show an implementation of the oracle OD , which relies solely on the representation of G1 , . . . , Gm . Additionally, we discuss a possible implementation of the local connector component that takes advantage of the fact that G represents a set of valid positions and movements of multiple robots. Finally, we argue that our dRRT-based approach to multi-robot motion planning is probabilistically complete. Recall that given C  V and a random sample q , D (C, q ) returns C such that C is a neighbor of C in G, and for every other neighbor C of C , (C, q ) forms a smaller angle with (C, C ), where  is as defined in Section III-D. Denote by C (ri ) the configuration space of ri . Let q = (q1 , . . . , qm ) where qi  C (ri ), and let C = (c1 , . . . , cm ) where ci	Vi . To find a suitable neighbor for C we first find the most suitable neighbor for every individual robot and combine the m single-robot neighbors into a candidate neighbor for C . We denote by ci = OD (ci , qi ) the neighbor of ci in Gi that is in the direction of qi . Notice that the implementation of the oracle for individual roadmaps is trivial--traversing all the neighbors of ci in Gi 4 . Let C = (c1 , . . . , cm ) be a candidate for the result of D (C, q ). If (C, C ) represents a valid edge in G, i.e., no robot-robot collision occurs, we return C . Otherwise, D (C, q ) returns . In this case, the new sample is ignored and another sample is drawn in the EXPAND phase (Algorithm 2). The generalization of the completeness proof of the dRRT (Theorem 2) for the specific implementation of OD described above, is relatively straightforward. Notice that in order to extend C = (c1 , . . . , cm ) to C = (c1 , . . . , cm ) the sample q = (q1 , . . . , qm ) must obey the following restriction: For every robot ri , qi must lie in Vor(ci )  Vor (ci , ci ) (where in the original proof we required that q will lie in Vor(C )  Vor (C, C )). Since we restrict the proof for the vertices of the individual roadmaps, we can safely assume that the points (in C (ri )) are in general position (as required by Theorem 2), since they were randomly sampled by the PRM algorithm. B. Local Connector using M* Recall that in the general dRRT algorithm the local connector is used for connecting two vertices of a graph when it is believed that the pathfinding problem is simpler, as the
4 The complexity of this process can be reduced in some cases, at the cost of increase in storage.

distance between the two vertices is smaller than the distance between the original problem's source and target. In the setting of multi-robot motion planning, it is natural to measure the hardness of a given problem instance by the required degree of coupling. Thus, we assume that the problem of connecting two vertices by the local connector requires a lower degree of coupling than the input problem. As our local connector we use M*, as this method is known to be extremely efficient on scenarios where the degree of coupling is low. We mention that it is still possible that the local problem will turn out too challenging for the M* algorithm. In order to avoid situations where M* spends too much time on problems it is incapable to solve (due to prohibitive memory requirements), we terminate M* when it considers the coupling of too many robots. Alternatively, it is also possible to detect decoupled instances a-priori using the optimal decoupling method [23], and only then use M*. C. Probabilistic Completeness of the Framework  As mentioned in Section II, Svestka and Overmars [24] show that the composite roadmap approach is probabilistically complete, assuming that the roadmap is explicitly constructed and the individual roadmaps are generated using the PRM algorithm. As we have shown that dRRT is probabilistically complete, it follows that our framework for the multi-robot motion planning problem is probabilistically complete as well. As a side note, we mention that the proof in [24] was for the case of a composite roadmap that is a result of a Cartesian product, and here tensor product is used. Yet, the proof holds in our setting as well, as the Cartesian product results in a roadmap that is a subgraph of the tensor product roadmap. V. E XPERIMENTAL R ESULTS We implemented our framework for the case of disc robots translating in the plane amidst polygonal obstacles. We compared the performance of our algorithm with M* and other known methods on two sets of test cases. The first test case studies the effect the degree of coupling has on the algorithms, while the second examines the behavior of the algorithms on highly coupled scenarios. A. Implementation Details The algorithm was implemented in C++. The experiments were conducted on a PC with an Intel i7-2600 3.40GHz processor with 8GB of memory, running 64-bit Windows 7. We implemented a generic framework for multi-robot motion planning based on composite roadmaps. The framework has an implementation of the single-robot PRM algorithm (using the Boost Graph Library (BGL) [19]), collision detection (using the Computational Geometry Algorithms Library (CGAL) [21]), and nearest neighbor queries (using the Fast Library for Approximate Nearest Neighbors (FLANN) [15]). These allow the framework to implicitly represent the composite roadmap. The framework's design allowed us to compare different search strategies on the same composite roadmap.

A. Oracle OD

Parameters of the dRRT Algorithm. To eliminate the dependence of dRRT on parameters we assigned them according to the number of iterations the algorithm performed so far, i.e., the number of times that the main loop has been repeated. Specifically, in iteration i each EXPAND (Algorithm 2) call performs 2i iterations (N = 2i ), while CONNECT TREES performs i iterations (P = i). A call to the local connector was terminated when the number of robots that had to be coordinated exceeded 4. The PRM roadmaps of the individual robots were generated with k = 15 and n = 300. Using Multiple CPU Cores. We note that FLANN, the nearest neighbor library that was used, can speed up queries by utilizing multiple CPU cores. As we did not attempt to parallelize dRRT or M*, multiple cores were not used when the two algorithms were compared. For the highly coupled scenarios where M* failed to solve any instance, dRRT successfully solved them regardless of the number of cores used. The running times are slower (by a factor of three) when comparing a single core and four cores. The results presented for these scenarios in Table I are those using four cores. Recursive M*. Throughout this paper we addressed the M* algorithm, yet Wagner et al. also described a more efficient variant named recursive M* or rM* that subdivides separated but simultaneously interacting sets of robots to individual subproblems solved recursively. They showed that rM* is faster and has better memory consumption and hence we compare the dRRT running times with rM*. Relaxing the Optimality of rM*. M* and rM* retrieve the optimal path between two vertices of the composite roadmap. As dRRT does not take into account path quality, we use the inflated version [25] of rM* that biases the search towards the leaves of the search tree that are close to the goal. These are candidates where a solution is more likely to be found quickly. Cartesian vs. Tensor Composite Roadmap. As we described earlier, M* and rM* may exhibit high memory consumption when using a tensor composite roadmap. If one considers using a Cartesian roadmap, this limitation vanishes but the algorithm's running times increase drastically. This creates an interesting tradeoff between a fast, memory-consuming algorithm and a slow, yet memory-efficient variant. When using a tensor composite roadmap our approach is not affected by the high degree of each vertex, due to the use of the oracle. Thus, such a tradeoff does not exist and there is no motivation to consider using dRRT with a Cartesian composite roadmap. We ran rM* in all scenarios with both types of composite roadmaps and note that in all cases when rM* ran on a Cartesian roadmap, we either had to terminate the run after a timeout of 15 minutes or the average running times were larger than ours by a factor of 15. Due to this fact we only present the results when using a tensor composite roadmap. B. Test Scenarios The first set of tests consists of a workspace with 10 randomly placed robots that move to random goals amidst random obstacles. We gradually increased the coupling by

(a) (b) (c)

total time 45.1 3.5 22.1

expand time 39.7 0.4 12.4

connect time 5.4 3.1 9.7

expanded vertices 3.8  105 5.3	103 3.2  105

O(|V|) 8.1  109 7.3  1014 6.5  1019

TABLE I dRRT's results for scenarios (a)-(c) depicted in Figure 1. Total query time (in seconds) consist of expand time by the dRRT algorithm and connect time by the local connector. Additionally we report the number of vertices expanded by the algorithm and a bound on the total number of vertices represented by the implicit composite roadmap.

increasing the disk's radii (see Figure 3 (a)). This allowed us to compare the performance of dRRT and rM* for different levels of coupling. The second set of scenarios consists of highly coupled scenarios (see Figure 1 (a-c)) that no other pathfinding algorithm was able to solve within a reasonable time frame. We tried to run A*, M* and rM* on the implicit roadmap generated for these scenarios but the program terminated due to insufficient memory resources (or due to high running times as previously discussed). A similar result was observed when the KPUMP algorithm [20], that is not based on composite roadmaps, was tested on these scenarios. We mention that it has been shown that other sampling-based methods such as PRM and RRT, are incapable of dealing with such scenarios [20, 26], and therefore were not tested. All times reported are the average of 10 runs on each scenario after removing minimal and maximal outliers. Gradual Increase of Coupling. For the scenarios requiring a gradual increase of coupling, the rM* failed to find a path on several instances (either due to insufficient memory or due to running times exceeding 15 minutes). The results are presented in Figure 3. The dRRT's success rate is 100% for all tests while the rM* algorithm's success rate diminishes as the problem becomes highly coupled. When the rM* succeeds in finding a path, both algorithm's running times are comparable, and for the easier cases rM* has slightly better running times. Highly Coupled Scenarios. We report in Table I the running times of our framework for the highly coupled scenarios depicted in Figure 1 (a-c). We can see that although the scenarios require high coupling between robots, our planner manages to efficiently find valid paths. The amount of vertices expanded by the dRRT may seem quite large yet one should notice the very high (bound on the) number of vertices represented by the implicit composite roadmap. As mentioned earlier, the dRRT explores a tiny fraction of the configuration space while reaching locally simple problems that are solvable by M*. We wish to note that the majority of the running time in the expand stage is devoted to nearest neighbor queries. Thus the effectiveness of the nearest neighbor method has a huge impact on the performance of our algorithm. It is noteworthy that a similar phenomenon was observed in the work of Bialkowski et al. [3]. VI. F UTURE W ORK Towards Optimality. Currently, our algorithmic framework is concerned with finding a solution, and our immediate

100

rM* Success rate [%]

dRRT rM*

120

80 60

r2 r3 r4

80 60 40 40 20 0 r1 r2 r3 r4 20 0

Scenario

(a)

(b)

Fig. 3. Comparing dRRT and rM*. (a) Ten randomly placed robots that move to random goals (start and target locations are depicted by colored disks and annuli, respectively). The robots' radii are gradually increased creating an increase in the coupling required. Different radii are depicted at the right-hand side of the figure ranging from smallest (r1) to largest (r4). (b) Results for the different radii for the scenario. Success rate for rM* is depicted by shaded bars (dRRT had 100% success rate in all cases). Query time for the dRRT and rM* algorithms is depicted by line segments.

future goal is to modify it to provide a solution with quality assurance. We believe that the following modification will help in achieving this goal. An obvious requirement is that dRRT will be made optimal, possibly by taking an approach similar to the continuous RRT* algorithm [9], which is known to be optimal. RRT* differs from the original formulation of RRT in an additional step where the structure of the tree is revised to improve previously examined paths. Specifically, when a new node is added to the tree, it is checked as to whether it will be more beneficial for some of the existing nodes to point to the new vertex instead of their current parent in the tree. This can be adapted, to some extent, to the discrete case, although it is not clear whether this indeed will lead to optimal paths. Framework Extensions. Our current implementation of dRRT disregards various technicalities that should be addressed such as: How many trees to grow? Should the tree's growth be occasionally biased to the target vertex? How far should each vertex be extended? We believe that by addressing these issues it would be possible to improve the performance of the algorithm. We mention that these aspects (and many others) have already been discussed in the continuous setting [13]. We believe that the dRRT algorithm, developed in this work, can be used as a general pathfinding tool for geometricallyembedded graphs. We foresee the algorithm applied to other problems in robotics as well as in other fields of research. We also wish to extend the algorithm to other variants of the multi-robot problem such as the k -color problem [20], where several groups of identical robots operate in the same workspace, and the target positions are shared among robots from the same group. The extension is not trivial since the composite roadmap now contains exponentially many vertices that represent valid target positions (as opposed to a single target vertex in the basic problem). VII. ACKNOWLEDGEMENTS We wish to thank Glenn Wagner for advising on the M* algorithm and Ariel Felner for advice regarding pathfinding algorithms on graphs. We note that the title "Finding a Needle in an Exponential Haystack" has been previously used in a talk by Joel Spencer in a different context.

R EFERENCES [1] Graph Product -- Wikipedia, The Free Encyclopedia, 2013.  [2] B. Aronov, M. de Berg, A. F. van der Stappen, P. Svestka, and J. Vleugels. Motion Planning for Multiple Robots. Discrete & Computational Geometry, 22(4):505525, 1999. [3] J. Bialkowski, S. Karaman, M. Otte, and E. Frazzoli. Efficient Collision Checking in Sampling-Based Motion Planning. WAFR, in press, 2012. [4] M. S. Branicky, M. M. Curtiss, J. A. Levine, and S. B. Morgan. RRTs for Nonlinear, Discrete, and Hybrid Planning and Control. In Decision and Control, pages 912, 2003. [5] H. Choset, K. Lynch, S. Hutchinson, G. Kantor, G. Burgard, L. Kavraki, and S. Thrun. Principles of Robot Motion: Theory, Algorithms, and Implementations. MIT Press, 2005. [6] M. de Berg, M. van Kreveld, M. Overmars, and O. Schwarzkopf. Computational Geometry: Algorithms and Applications. Springer-Verlag, third edition, 2008. [7] S. Hirsch and D. Halperin. Hybrid Motion Planning: Coordinating Two Discs Moving among Polygonal Obstacles in the Plane. In WAFR, pages 239255. Springer, 2002. [8] J.E. Hopcroft, J.T. Schwartz, and M. Sharir. On the Complexity of Motion Planning for Multiple Independent Objects; PSPACE-Hardness of the "Warehouseman's Problem". IJRR, 3(4):7688, 1984. [9] S. Karaman and E. Frazzoli. Sampling-Based Algorithms for Optimal Motion Planning. IJRR, 30(7):846894, 2011.  [10] L. E. Kavraki, P. Svestka, J.-C. Latombe, and M. Overmars. Probabilistic Roadmaps for Path Planning in High Dimensional Configuration Spaces. IEEE Transactions on Robotics and Automation, 12(4):566580, 1996. [11] J. J. Kuffner and S. M. LaValle. RRT-Connect: An Efficient Approach to Single-Query Path Planning. In ICRA, pages 9951001, 2000. [12] S. M. LaValle. Planning Algorithms. Cambridge Uni-

Query time [sec]

r1

100

versity Press, 2006. [13] S. M. LaValle and J.J. Kuffner. Rapidly-exploring random trees: Progress and prospects. In Algorithmic and Computational Robotics: New Directions, pages 293 308, 2001. [14] S. Leroy, J. P. Laumond, and T. Simeon. Multiple Path Coordination for Mobile Robots: A Geometric Algorithm. In IJCAI, pages 11181123, 1999. [15] M. Muja and D. G. Lowe. Fast Approximate Nearest Neighbors with Automatic Algorithm Configuration. In VISSAPP, pages 331340. INSTICC Press, 2009. [16] J. Pearl. Heuristics: Intelligent Search Strategies for Computer Problem Solving. Addison-Wesley, 1984. [17] G. Sanchez and J.-C. Latombe. Using a PRM Planner to Compare Centralized and Decoupled Planning for MultiRobot Systems. In ICRA, 2002. [18] J. T. Schwartz and M. Sharir. On the Piano Movers' Problem: III. Coordinating the Motion of Several Independent Bodies. IJRR, 2(3):4675, 1983. [19] J. G. Siek, L.-Q. Lee, and A. Lumsdaine. The Boost Graph Library User Guide and Reference Manual. Addison-Wesley, 2002. [20] K. Solovey and D. Halperin. k -Color Multi-Robot Motion Planning. WAFR, in press, 2012. [21] The CGAL Project. CGAL User and Reference Manual. CGAL Editorial Board, 3.9 edition, 2011. [22] J. van den Berg and M. Overmars. Prioritized Motion Planning for Multiple Robots. In IROS, pages 430  435, 2005. [23] J. van den Berg, J. Snoeyink, M. Lin, and D. Manocha. Centralized Path Planning for Multiple Robots: Optimal Decoupling into Sequential Plans. In RSS, 2009.  [24] P. Svestka and M. Overmars. Coordinated Path Planning for Multiple Robots. Robotics and Autonomous Systems, 23:125152, 1998. [25] G. Wagner and H. Choset. M*: A Complete Multirobot Path Planning Algorithm with Performance Bounds. In IROS, pages 32603267. IEEE, 2011. [26] G. Wagner, M. Kang, and H. Choset. Probabilistic Path Planning for Multiple Robots with Subdimensional Expansion. In ICRA, pages 28862892, 2012.


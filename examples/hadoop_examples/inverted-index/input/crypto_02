Using LDGM Codes and Sparse Syndromes to Achieve Digital Signatures
Marco Baldi1 , Marco Bianchi1 , Franco Chiaraluce1 , Joachim Rosenthal2 , and Davide Schipani3
1

arXiv:1305.5436v1 [cs.CR] 23 May 2013

Universit` a Politecnica delle Marche, Ancona, Italy {m.baldi,m.bianchi,f.chiaraluce}@univpm.it 2 University of Zurich, Zurich, Switzerland rosenthal@math.uzh.ch 3 Nottingham Trent University, Nottingham, UK davide.schipani@ntu.ac.uk

Abstract. In this paper, we address the problem of achieving efficient code-based digital signatures with small public keys. The solution we propose exploits sparse syndromes and randomly designed low-density generator matrix codes. Based on our evaluations, the proposed scheme is able to outperform existing solutions, permitting to achieve considerable security levels with very small public keys. Keywords: Code-based digital signatures, LDGM codes, sparse syndromes

1

Introduction

The problem of replacing current cryptographic primitives which will be subject to quantum computer attacks with alternative post-quantum solutions is fostering research on code-based systems, which are among the most promising options for this replacement. Concerning asymmetric cryptography, the McEliece cryptosystem [21] and its recent improvements [9] already represent efficient solutions to replace quantum vulnerable systems, like RSA. The main drawback of the McEliece cryptosystem compared to RSA is the large size of its public keys. However, great steps have been done towards the reduction of the McEliece public key size. A possible solution consists in replacing the Goppa codes used in the original system with other families of codes. Among these, low-density parity-check (LDPC) codes have been considered since several years [13, 24], and most recent proposals based on them have been able to achieve significant reductions in the key size [6, 7, 23]. For what concerns digital signatures, the widespread DSA and RSA signature schemes will be endangered by quantum computers as well, and only a few
This work was supported in part by the MIUR project "ESCAPADE" (Grant RBFR105NLC) under the "FIRB - Futuro in Ricerca 2010" funding program, and in part by the Swiss National Science Foundation under grant No. 132256.

2

M. Baldi, M. Bianchi, F. Chiaraluce, J. Rosenthal, D. Schipani

replacements are available up to now, like hash-based signatures. Code-based digital signature schemes represent another post-quantum alternative to DSA and RSA signature schemes, but the development of efficient code-based solutions is still challenging. The two main proposals of code-based signature schemes currently available are the Courtois-Finiasz-Sendrier (CFS) scheme [13] and the KabatianskiiKrouk-Smeets (KKS) scheme [18]. An up-to-date discussion about these two systems can be found in [15] and [26], respectively. The KKS scheme uses two codes with different sizes to create the trapdoor, one selecting the subset support of the other. An important weakness of this system was recently pointed out in [26], even though the KKS scheme can still be considered secure for some choices of its parameters. The CFS signature scheme instead uses a hash-and-sign paradigm based on the fact that only the authorized signer can exploit the error correction capability of a secret code. The main components of the CFS scheme are a private t-error correcting code C and a public hash algorithm H. The private code is described through its parity-check matrix H , while H  = S  H is made public, where S is a private random matrix. There must be a public function F able to transform (in a reasonable time) any hash value computed through H into a correctable syndrome for the code C . Then, syndrome decoding through C is performed by the signer, and the resulting error vector e is the digital signature, together with the parameters to be used in the function F for achieving the target. Verification is easily obtained by computing H   e and comparing the result with the output of F . The main drawback of the CFS scheme concerns the function F . In fact, it is very hard to find a function that quickly transforms an arbitrary hash vector into a correctable syndrome. In the original CFS scheme, two ways are proposed to solve this problem [15]: i) appending a counter to the message, or ii) performing complete decoding. Both these methods require a very special choice of the code parameters to be able to find decodable syndromes within a reasonable time. For this purpose, codes with very high rate and very small error correction capability are commonly used, and this has exposed the cryptosystem to attacks based on the generalized birthday algorithm [14], in addition to common attacks against code-based cryptosystems. This flaw is mainly due to the need to ensure that many vectors produced by the hash function H are correctable. In addition, in such a setting, the decoding complexity can be rather high, especially in the versions exploiting complete decoding. In this paper, we propose a new solution based on a modification of the CFS scheme. The first variation is to consider only a subset of the possible syndromes, selecting the ones having a certain density (of not null elements). In addition, we replace traditional Goppa codes with low-density generator-matrix (LDGM) codes, which allow for a random based design and a considerable reduction in the public key size. As it will be shown in the following, this allows to relax many constraints on the code parameters, and therefore to use more practical codes which also make classical attacks against the CFS scheme inap-

Using LDGM Codes and Sparse Syndromes to Achieve Digital Signatures

3

plicable. In addition, syndrome decoding through the private code is reduced to a straightforward procedure, with an extremely low complexity. The rationale of the proposed system is in the following observations:  Given a private parity-check matrix in systematic form (with an identity block in the rightmost part), the signer can obtain an error vector associated to a given syndrome by simply transposing the syndrome and prepending it with an all zero vector. By obtaining the public parity-check matrix from the private one through a left and right multiplication by two dense secret matrices, the systematic form is lost and the same procedure cannot be exploited by an attacker. Moreover, the two parity-check matrices no longer describe the same code.  The private error vector obtained by the signer can be disguised by adding to it a randomly selected codeword of the secret code.  If both the private error vector and the random codeword are of moderately low weight, and the same holds for their transposition into the public code, they are difficult to discover by an attacker.  If the private code is an LDGM code, it is very easy for the signer to randomly select a low weight codeword, since it is obtained as the sum of a small number of rows of its generator matrix, chosen at random. Although the private code is an LDGM code, its parity-check matrix in systematic form can be dense. In the following sections we show how these observations are translated into practice in the proposed system. The organization of the paper is as follows. In Section 2, we describe the LDGM codes we use in the system and their characteristics. In Section 3, we define the main steps of the system, that are: key generation, signing procedure and verification procedure. In Section 4, we provide a preliminary assessment of the possible vulnerabilities affecting the system. In Section 5, we give some possible choices of the system parameters and, finally, Section 6 concludes the paper.

2

Low-density generator-matrix codes

LDGM codes have been used since a long time for transmission applications [12], and are recognized to achieve very good error correcting performance when used in concatenated schemes [16], [17]. A simple way to obtain an LDGM code with length n, dimension k and redundancy r = n - k is to define its generator matrix in the form G = [Ik |D], (1)

where Ik is a k k identity matrix, and D is a sparse k r matrix. We suppose that the rows of G have Hamming weight wg  n. An LDGM code can also be defined with G in a more general form than (1), that is, by randomly selecting k linearly independent vectors with length n and Hamming weight wg  n, and using them

4

M. Baldi, M. Bianchi, F. Chiaraluce, J. Rosenthal, D. Schipani

as the rows of G. This approach requires to check the linear independence of the rows of G, but it increases the degrees of freedom for random-based designs. Hence, we consider this more general solution for the design of the private code in the proposed system. Due to their sparse nature, it is very likely that, by summing two or more rows of the generator matrix of an LDGM code, a vector with Hamming weight  wg is obtained. In this case, the LDGM code has minimum distance wg . This is even more likely if the rows of G are chosen in such a way as to be quasi-orthogonal, that is, with a minimum number of overlapping ones. However, in the scheme we propose, we do not actually need that the secret code has minimum distance wg . Hence, G can be designed completely at random, without any constraint on the number of overlapping ones between each pair of its rows. The code defined through G as in (1) is systematic and admits a sparse parity check matrix H in the form H = [DT |Ir ], (2) where T denotes transposition and Ir is an r  r identity matrix. Hence, such a code is an LDPC code as well. On the contrary, if G is designed completely at random, without imposing the form (1), it is not systematic and the LDGM code is generally not an LDPC code. This is the case for the private LDGM code which is used in the proposed system. A particularly interesting class of LDGM codes is that of quasi-cyclic (QC) LDGM codes [4]. In fact, the QC property allows to reduce the memory needed to store the code characteristic matrices, which is an important feature in cryptographic applications where such matrices are used as private and public keys. A general form for the generator matrix of a QC-LDGM code is as follows:	 C0,0 C0,1 C0,2 . . . C0,n0 -1	C1,0 C1,1 C1,2 . . . C1,n0 -1	  C2,0 C C2,2 . . . C2,n0 -1  2,1 GQC =  (3) ,	 . . . . . . . . . .   . . . . . Ck0 -1,0 Ck0 -1,1 Ck0 -1,2 . . . Ck0 -1,n0 -1 where Ci,j represents a sparse circulant matrix or a null matrix with size p  p. Hence, in this case the code length, dimension and redundancy are n = n0 p, k = (n0 - r0 )p = k0 p and r = r0 p, respectively. Since a circulant matrix is defined by one of its rows (conventionally the first), storing a binary matrix GQC as in (3) requires k0 n0 p = kn/p bits, and the corresponding parity-check matrix HQC requires r0 n0 p = rn/p bits to be stored. The proposed system uses a parity-check matrix as the public key; so, when adopting QC-LDGM codes, its public key size is rn/p bits. An important feature of LDGM codes which will be exploited in the proposed scheme is that it is easy to obtain a random codeword c belonging to an LDGM code and having weight approximately equal to a fixed, small value wc . Let us suppose that wc is an integer multiple of wg . Since the rows of G are sparse, it is highly probable that, by summing a small number of rows, the Hamming

Using LDGM Codes and Sparse Syndromes to Achieve Digital Signatures

5

weight of the resulting vector is about the sum of their Hamming weights. Hence, wc rows of G, chosen at random, we get a random codeword with by summing w g Hamming weight about wc . Actually, due to some overlapping ones, the resulting weight could result smaller than wc . In this case, some other row can be added, or some row replaced, or another combination of rows can be tested, in order to approach wc . Moreover, as we will see in the following, using a random codeword with Hamming weight slightly smaller than wc is not a problem in the proposed system. Based on the above considerations, the number of codewords with weight close to wc which can be easily selected at random from an LDGM code having G with rows of weight wg , with wg |wc , can be roughly estimated as Awc  k
wc wg

.

(4)

3

System description

In this section we describe the main steps of the proposed digital signature system. 3.1 Key generation

The first part of the private key for the proposed system is formed by the r  n parity-check matrix H of an LDGM code C (n, k ), having length n and dimension k (r = n - k ). The matrix H is in systematic form, with an identity block in the rightmost part. The private key also includes two other non-singular matrices: an r  r transformation matrix Q and an n  n scrambling matrix S (both defined below). The public key is then obtained as H  = Q-1  H  S -1 . The matrix S is a sparse non-singular matrix, with average row and column weight mS  n. The matrix Q, instead, is a weight controlling transformation matrix as defined in [5]. For this kind of matrices, when s is a suitably chosen sparse vector, the vector s = Q  s has a small Hamming weight, which is only a few times greater than that of s. As shown in [5], a matrix Q with such a feature can be obtained as the sum of an r  r low-rank dense matrix R and a sparse matrix T , chosen in such a way that Q = R + T is non singular. In order to design R, we start from two z  r matrices, a and b, with z < r properly chosen (see below), and define R as: R = aT  b. (5) This way, R has rank  z . The matrix T is then chosen as a sparse matrix with row and column weight mT , such that Q = R + T is full rank. It can be easily verified that, if the vector s is selected in such a way that b  s = 0z1 , where 0z1 is the z  1 all-zero vector, then R  s = 0r1 and s = Q  s = T	s. Hence, the Hamming weight of s is, at most, equal to mT times that of s, and Q actually has the weight controlling feature we desire. As we will see in Section 4.3, although it is relatively simple for an attacker to obtain the space defined by the matrix b, and its dual space, this does not

6

M. Baldi, M. Bianchi, F. Chiaraluce, J. Rosenthal, D. Schipani

help to mount a key recovery attack. Hence, the matrix b, which is only a small part of Q, can even be made public. When a QC code is used as the private code, H is formed by r0  n0 circulant matrices of size p  p, and it is desirable to preserve this QC structure also for H  , in such a way as to exploit its benefits in terms of key size. For this purpose, both Q and S must be formed by circulant blocks with the same size as those forming H . Concerning the matrix S , it is obtained in QC form (SQC ) by simply choosing at random a block of n0  n0 sparse or null circulant matrices such that the overall row and column weight is mS . Concerning the matrix Q, instead, a solution to obtain it in QC form is to define R as follows: RQC = aT (6) r0  br0  1pp , where ar0 and br0 are two z  r0 binary matrices, 1pp is the all-one p  p matrix and  denotes the Kronecker product. Then, TQC is chosen in the form of n0  n0 sparse circulant blocks with overall row and column weight mT and 1 -1 QQC is obtained as RQC + TQC . This way, if H is in QC form, H  = Q- QC  H  SQC is in QC form as well. In the QC case, the condition we impose on s, that is, b  s = 0z1 becomes (br0	11p )  s = 0z1 . Such a condition, both in the generic and in the QC case, is equivalent to a set of z parity-check constraints for a code with length r and redundancy z . Hence, if we fix b such that this code has minimum distance d, then a vector s with weight w < d cannot satisfy such condition, and Q loses its weight controlling feature on s. This is useful to reinforce the system against some vulnerabilities, and justifies the form used for the matrix Q. Apart from the private and public key pair, the system needs two functions which are made public as well: a hash function H and a function F that converts the output vector of H into a sparse r-bit vector s of weight w  r. The output of F depends on the parameter , which is associated to the message to be signed and made public by the signer. An example of implementation of F is provided in the next section. 3.2 Signature generation

In order to get a unique digital signature from some document M , the signer computes the digest h = H(M ) and then finds M such that s = FM (h) verifies b  s = 0z1 . Since s has weight w, s = Q  s has weight  mT w. Concerning the implementation of the function F (h), an example is as follows. Given a message digest h = H(M ) of length x bits, similarly to what is done in the CFS scheme, it is appended with the y -bit value l of a counter, thus obtaining [h|l]. r The value of [h|l] is then mapped uniquely into one of the w r-bit vectors of r x +y weight w, hence it must be w  2 . The counter is initially set to zero by the signer, and then progressively increased. This way, a different r-bit vector is obtained each time, until one orthogonal to b is found, for l =	l. This step requires the signer to test 2z different values of the counter, on average. With this

Using LDGM Codes and Sparse Syndromes to Achieve Digital Signatures

7

, and different signatures correspond implementation of F (h), we have M = l to different vectors s, unless a hash collision occurs. After having obtained s, the signer has to find a vector e of weight  mT w which corresponds to the private syndrome s = Q  s through C . Since H is in systematic form, it can be written as H = [X |Ir ], where X is an r  k matrix and Ir is the r  r identity matrix. Hence, the private syndrome s can be obtained from the error vector e = [01k |sT ]. So, in this case, finding e simply translates into a vector transposition and some zero padding. The signer finally selects a random codeword c  C with small Hamming weight (wc ), and computes the public signature of M as e = (e + c)  S T . If the choice of the codeword c is completely random and independent of the document to be signed, the signature obtained for a given document changes each time it is signed, and the system becomes vulnerable to attacks exploiting many signatures of the same document. This can be simply avoided by choosing the codeword c as a deterministic function of the document M and, hence, of the public syndrome s. For example, s or, equivalently, [h| l] can be used as the initial state of the pseudo-random integer generator through which the signer extracts the indexes of the rows of G that are summed to obtain c. This way, the same codeword is always obtained for the same public syndrome. To explain the role of the codeword c, let us suppose for a moment that the system does not include any random codeword, that is equivalent to fix c = 01n , M . In this case, we could write e = W (s), where W is a linear bijective map from the set of public syndromes to the set of valid signatures. This can be easily verified, since it is simple to check that W (s1 +s2 ) = W (s1 )+W (s2 ). So, an attacker who wants to forge a signature for the public syndrome sx could simply express sx as a linear combination of previously intercepted public syndromes, sx = si1 + si2 + . . . siN , and forge a valid signature by linearly combining their    corresponding signatures: e x = ei1 + ei2 + . . . eiN . As mentioned, to prevent this risk, the signer adds a random codeword c, with weight wc  n, to the error vector e, before multiplication by S T . This way, the map W becomes an affine map which depends on the random codeword c, and it no longer has the set of valid signatures as its image. In fact, we can denote this  new map as Wc (s), such that e 1 = Wc1 (s1 ) and e2 = Wc2 (s2 ), where c1 and c2 are two randomly selected codewords of the private code with weight wc . If we   linearly combine the signatures, we obtain e f = e1 + e2 = Wc1 (s1 ) + Wc2 (s2 ) = Wc1 +c2 (s1 + s2 ). The vector c1 + c2 is still a valid codeword of the secret code, but it has weight > wc with a very high probability. 3.3 Signature verification

After receiving the message M , its signature e and the associated parameter M , the verifier first checks that the weight of e is  (mT w + wc )mS . If this condition is not satisfied, the signature is discarded. Then the verifier computes s = FM (H(M )) and checks that s has weight w, otherwise the signature is discarded. If the previous checks have been positive, the verifier then computes

8

M. Baldi, M. Bianchi, F. Chiaraluce, J. Rosenthal, D. Schipani

H  eT = Q-1 H S -1 S (eT +cT ) = Q-1 H (eT +cT ) = Q-1 H eT = Q-1 s = s. If s = s, the signature is accepted; otherwise, it is discarded. 3.4 Number of different signatures

An important parameter for any digital signature scheme is the total number of different signatures. In our case, a different signature corresponds to a different rbit vector s, having weight w. Only vectors s satisfying the z constraints imposed by b are acceptable, so the maximum number of different signatures is: Ns
r w 2z

.

(7)

4

Possible vulnerabilities

For a security assessment of the proposed system, it would be desirable to find possible security reductions to some well known hard problems, and then to evaluate the complexity of practical attacks aimed at solving such problems. This activity is still at the beginning, and work is in progress in this direction. Hence, in this paper we only provide a sketch of some possible vulnerabilities we have already devised, which permit to obtain a first rough estimate of the security level of the system. Completing the security assessment will allow to improve the security level estimation, and possibly to find more effective choices of the system parameters. From the definition of the proposed system, it follows that the published signature e associated to a document M is always a sparse vector, with Hamming weight  (mT w + wc )mS . Since e is an error vector corresponding to the public syndrome s through the public code parity-check matrix H	, having a low Hamming weight ensures that e is difficult to find, starting from s and H  . This is achieved by using the weight controlling matrix Q and the sparse matrix S . If this was not the case, and e was a dense vector, it would be easy to forge signatures, since a dense vector corresponding to s through H  is easy to find. Based on these considerations, one could think that choosing both Q and S as sparse as possible would be a good solution. Let us suppose that they are two permutation matrices, P1 and P2 . In this case, the public matrix would be T T  H  P2 , and both s and e would be sparse, thus avoiding easy forgeries. H  = P1 Actually, a first reason for avoiding to use permutation matrices is that, when masked only through permutations, the security of H decreases. In fact, using a doubly permuted version of H may still allow to perform decoding through the public code. However, neglecting for a moment this fact, we find that, in this case, e would have weight	w + wc . If e and c have disjoint supports, which is very likely true, since we deal with sparse vectors, w non-zero bits in e would correspond to a reordered version of the non-zero bits in s. So, apart from the effect of the random codeword, we would simply have a disposition of the non-zero bits in s within e , according to a fixed pattern. This pattern could be discovered by an attacker who observes a sufficiently large number

Using LDGM Codes and Sparse Syndromes to Achieve Digital Signatures

9

of signatures, so that the effect of the random codeword could be eliminated. In fact, by computing the intersection of the supports of many vectors s and their corresponding vectors e , the support of e could be decomposed and the reordering of each bit disclosed. Based on these considerations, we can conclude that the density of e must be carefully chosen between two opposite needs:  being sufficiently low to avoid forgeries;  being sufficiently high to avoid support decompositions. 4.1 Forgery attacks

In order to forge signatures, an attacker could search for an n  r right-inverse   matrix Hr of H  . Then, he could compute f = (Hr  s)T , which is a forged signature. It is easy to find a right-inverse matrix able to forge dense signatures. -1  In fact, provided that H	 H T is invertible, Hr = H T  H   H T is a right  inverse matrix of H . The matrix H is dense and the same occurs, in general, -1  for H   H T ; so, Hr is dense as well. It follows that, when multiplied by s,  Hr produces a dense vector, thus allowing to forge dense signatures. By using sparse signatures, with weight	(mT w + wc )mS , the proposed system is robust against this kind of forged signatures. However, the right-inverse matrix is not unique. So, the attacker could search for an alternative, possibly sparse, right-inverse matrix. In fact, given an n  n -1  matrix Z such that H   Z  H T is invertible, Hr = Z  H T  H   Z  H T   is another valid right-inverse matrix of H  . We notice that Hr = Z	Hr . When  H contains an invertible r  r square block, there is also another simple way to find a right-inverse. It is obtained by inverting such block, putting its inverse at the same position (in a transposed matrix) in which it is found within H  , and padding the remaining rows with zeros. In any case, there is no simple way to find a right-inverse matrix that is also sparse, which is the aim of an attacker. Actually, for the matrix sizes considered here, the number of possible choices of Z is always huge. Moreover, there is no guarantee that any of them produces a sparse right-inverse. Searching for an r r invertible block within H  and inverting it would also produce unsatisfactory results, since the overall density of H -1 is reduced, but the inverse of the square block is still dense. So, the attacker would be able to forge signatures with a number of symbols 1 on the order of r/2, that is still too large for the system considered here. In fact, in the system examples we provide in Section 5, we always consider public signatures with weight on the order of r/3 or less. A further chance is to exploit Stern's algorithm [29] (or other approaches for searching low weight codewords) to find a sparse representation of the column   space of Hr . If this succeeds, it would result in a sparse matrix HS = Hr  B , for some r  r transformation matrix B . However, in this case, HS would not be a right-inverse of H  . For these reasons, approaches based on right-inverses seem to be infeasible for an attacker. An alternative attack strategy could be based on decoding. In fact,

10

M. Baldi, M. Bianchi, F. Chiaraluce, J. Rosenthal, D. Schipani

an attacker could try syndrome decoding of s through H	, hoping to find a sparse vector f . He would have the advantage of searching for one out of many possible vectors, since he is not looking for a correctable error vector. Several algorithms could be exploited for solving such problem [8, 10, 11, 20, 27]. These algorithms are commonly used to search for low weight vectors with a null syndrome, but, with a small modification, they can also be used to find vectors corresponding to a given (non-zero) syndrome. In addition, their complexity decreases when an attacker has access to a high number of decoding instances, and wishes to solve only one of them [28], which is the case for the proposed system. We will discuss the complexity issue in Section 5.

4.2

Support decomposition attacks

Concerning support decomposition, let us suppose that e and c have disjoint supports. In this case, the overall effect of the proposed scheme on the public syndrome s can be seen as the expansion of an r  1 vector s of weight w into a subset of the support of the 1  n vector e , having weight  mT mS w, in which each symbol 1 in s corresponds, at most, to m = mT mS symbols 1 in e . An attacker could try to find the w sets of m (or less) symbols 1 within the support of e in order to compute valid signatures. In this case, he will work as if the random codeword was absent, that is, c = 01n . Thus, even after succeeding, he would be able to forge signatures that are sparser than the authentic ones. In any case, this seems a rather dangerous situation, so we should aim at designing the system in such a way as to avoid its occurrence. To reach his target, the attacker must collect a sufficiently large number L of pairs (s, e ). Then, he can intersect the supports (that is, compute the bit-wise AND) of all the s vectors. This way, he obtains a vector sL that may have a small weight wL	1. If this succeeds, the attacker analyzes the vectors e , and selects the mwL set bit positions that appear more frequently. If these bit positions are actually those corresponding to the wL bits set in sL , then the attacker has discovered the relationship between them. An estimate of the probability of success of this attack can be obtained through combinatorial arguments. An even more efficient strategy could be to exploit information set decoding to remove the effect of the random codeword. In fact, an attacker knows that e = (e + c)  S T = e + c , with c such that H  c = 0. Hence, e can be considered as an error vector with weight  mT mS w affecting the codeword c of the public code. So the attacker could consider a random subset of k coordinates of the public signature e and assume that no errors occurred on these coordinates. In this case, he can easily recover c and, hence, remove the effect of the random codeword c. The probability that there are no errors in mS w the chosen k coordinates is n-mT / n k k , and its inverse provides a rough estimate of the work factor of this attack.

Using LDGM Codes and Sparse Syndromes to Achieve Digital Signatures

11

4.3

Key recovery attacks

An attacker could aim to mount a key recovery attack, that is, to obtain the private code. A potential vulnerability in this sense comes from the use of LDGM codes. As we have seen in Section 2, LDGM codes offer the advantage of having a predictable (and sufficiently high) number of codewords with a moderately low weight wc , and of making their random selection very easy for the signer. On the other hand, when the private code is an LDGM code, the public code T admits a generator matrix in the form G I = G  S , which is still rather sparse. So, the public code contains low weight codewords, coinciding with the rows of  G I , which have weight approximately equal to wg  mS . Since GI has k rows, and summing any two of them gives higher weight codewords with a very high probability, we can consider that the multiplicity of these words in the public code is k . They could be searched by using again Stern's algorithm [29] and its improved versions [8, 10, 11, 20, 27], in such a way as to recover G I . After that, T G could be separated into G and S by exploiting their sparsity. In Section 5 I we discuss how to estimate the work factor of this attack. Another possible vulnerability comes from the fact that the matrix b is public. Even if b was not public, an attacker could obtain the vector space generated by b, as well as its dual space, by observing O(r) public syndromes s, since b  s = 0z1 . Hence, we must suppose that an attacker knows an r  r matrix V such that R  V = 0  Q  V = T  V . The attacker also knows that H  = Q-1  H  S -1 and that the public code admits any non-singular generator matrix in the form T T  for X = Q. Obviously, G G I X = X  G  S , which becomes GQ = Q  G  S is the sparsest among them, and it can be attacked by searching for low weight codewords in the public code, as we have already observed. Instead, knowing V is useless to reduce the complexity of attacking either H  or one of the possible G X, hence it cannot be exploited by an attacker to perform a key recovery attack. 4.4 Other attacks

As for any other hash-and-sign scheme, classical collision birthday attacks represent a threat for the proposed system. Since  the system admits up to Ns different signatures, it is sufficient to collect  Ns different signatures to have a high probability of finding  a collision [19]. Hence, the security level reached by the system cannot exceed Ns . However, Ns can be made sufficiently high by increasing the value of w. The definition of the proposed system allows to choose its parameters in such a way as to guarantee this fact, as we will see in Section 5. This is possible since the choice of w is not constrained by the row weight of the private generator matrix. In fact, in the proposed scheme we do not actually need a private code of minimum distance greater than 2w, because we rely on a decoding procedure which uniquely associates to a syndrome of a given weight an error vector with the same weight, though such an error vector is not necessarily unique. Finally, it is advisable to consider the most dangerous attacks against the CFS scheme. It was successfully attacked by exploiting syndrome decoding based on

12

M. Baldi, M. Bianchi, F. Chiaraluce, J. Rosenthal, D. Schipani

the generalized birthday algorithm [14], even if the proposed attacking algorithm was not the optimal generalization of the birthday algorithm [22]. If we do not take into account some further improvement due to the QC structure of the public key, these algorithms provide a huge work factor for the proposed system parameters, since they try to solve the decoding problem for a random code. Just to give an idea, we obtain a work factor of more than 2200 binary operations even for the smallest key sizes we consider. However, there are some strategies that can be implemented to improve the efficiency of the attack on structured matrices, like those of dyadic codes [25]. This improvement could be extended to QC codes as well, but the attack work factor, for the cryptosystems analyzed in [25], is lowered by (at most) 210 binary operations, starting from a maximum value of 2344 . Hence, it is very unlikely that this strategy can endanger the signature scheme we propose.

5

System examples

By using the preliminary security assessment reported in Section 4, we can find some possible choices of the system parameters aimed at reaching fixed security levels. For this purpose, we have considered all the vulnerabilities described in Section 4, and we have estimated the work factor needed to mount a successful attack exploiting each of them. We have used the implementation proposed in [27] for estimating the work factor of low weight codeword searches. Actually, [27] does not contain the most up-to-date and efficient implementation of information set decoding. In fact, some improvements have appeared in the literature concerning algorithms for decoding binary random codes (as [20], [8]). These papers, however, aim at finding algorithms which are asymptotically faster, by minimizing their asymptotic complexity exponents. Instead, for computing the work factor of attacks based on decoding, we need actual operation counts, which are not reflected in these recent works. Also "ball collision decoding" [10] achieves significant improvements asymptotically, but they become negligible for finite code lengths and not too high security levels. For these reasons, we prefer to resort to [27], which provides a detailed analysis of the algorithm, together with a precise operation count for given code parameters. On the other hand, attacks against the proposed system which exploit decoding, i.e., trying to recover the rows of G or to forge valid signatures through decoding algorithms, are far away from providing the smallest work factors, and, hence, to determine the security level. For the choices of the system parameters we suggest, the smallest work factor is always achieved by attacks aiming at decomposing the signature support, which hence coincides with the security level. For the instances proposed in this section, the work factor of attacks based on decoding is on the order of 22SL , where SL is the claimed security level. Hence, even considering some reduction in the work factor of decoding attacks would not change the security level of the considered instances of the system. This situation does not change even if we consider the improvement coming from the "decoding one out of many" approach [28]. In

Using LDGM Codes and Sparse Syndromes to Achieve Digital Signatures

13

Table 1. System parameters for some security levels (SL), with d = 2 and wL = 2. SL (bits) 80 120 160 n 9800 k 4900 p w w g wc z m T m S 1 1 1 9 Awc 2
82.76

Ns 2 2 2
166.10 242.51 326.49

Sk (KiB) 117 570 1685

50 18 20 160 2

24960 10000 80 23 25 325 2 46000 16000 100 29 31 465 2

14 2 20 2

140.19 169.23

fact, as shown in [28], even if an attacker has access to an unlimited number of decoding instances, the attack complexity is raised by a power slightly larger than 2/3. Concerning support decomposition attacks, a rough estimation of their complexity has instead been obtained through simple combinatorial arguments, which are not reported here for the sake of brevity. A more detailed analysis of the attacks work factor is out of scope of this paper, and will be addressed in future works, together with a more complete security assessment. This will also permit to refine the choice of the system parameters, in such a way as to find the best trade-off between the security level and the key size. Table 1 provides three choices of the system parameters which are aimed at achieving 80-bit, 120-bit and 160-bit security, respectively. All these instances of the system use QC-LDGM codes with different values of p, also reported in the table, and consider the case in which the matrix Q is such that d = wL = 2. Actually, achieving minimum distance equal to 2 (or more) is very easy: it is sufficient to choose z > 1 and to guarantee that the matrix b does not contain all-zero columns. For each instance of the system, the value of the key size Sk is also shown, expressed in kibibytes (1 KiB = 1024  8 bits). In the original version of the CFS system, to achieve an attack time and memory complexity greater than 280 , we need to use a Goppa code with length n = 221 and redundancy r = 21  10 = 210 [14]. This gives a key size on the order of 4.4  108 bits = 52.5 MiB. By using the parallel CFS proposed in [15], the same work factor can be reached by using keys with size ranging between 1.05  107 and 1.7  108 bits, that is, between 1.25 MiB and 20 MiB. As we notice from Table 1, the proposed system requires a public key of only 117 KiB to achieve 80-bit security. Hence, it is able to achieve a dramatic reduction in the public key size compared to the CFS scheme, even when using a parallel implementation of the latter. Another advantage of the proposed solution compared to the CFS scheme is that it exploits a straightforward decoding procedure for the secret code. On the other hand, 2z attempts are needed, on average, to find an s vector such that b  s = 0z1 . However, such a check is very simple to perform, especially for very small values of z , like those considered here.

14

M. Baldi, M. Bianchi, F. Chiaraluce, J. Rosenthal, D. Schipani

6

Conclusion

In this paper, we have addressed the problem of achieving efficient code-based digital signatures with small public keys. We have proposed a solution that, starting from the CFS schemes, exploits LDGM codes and sparse syndromes to achieve good security levels with compact keys. The proposed system also has the advantage of using a straightforward decoding procedure, which reduces to a transposition and a concatenation with an all-zero vector. This is considerably faster than classical decoding algorithms used for common families of codes. The proposed scheme allows to use a wide range of choices of the code parameters. In particular, the low code rates we adopt avoid some problems of the classical CFS scheme, due to the use of codes with high rate and small correction capability. On the other hand, using sparse vectors may expose the system to new attacks. We have provided a sketch of possible vulnerabilities affecting this system, together with a preliminary evaluation of its security level. Work is in progress to achieve more precise work factor estimates for the most dangerous attacks.

References
1. M. Baldi and F. Chiaraluce, "Cryptanalysis of a new instance of McEliece cryptosystem based on QC-LDPC codes," Proc. IEEE International Symposium on Information Theory (ISIT 2007), Nice, France, Jun. 2007, pp. 25912595. 2. M. Baldi, F. Chiaraluce, R. Garello, and F. Mininni, "Quasi-cyclic low-density parity-check codes in the McEliece cryptosystem," Proc. IEEE International Conference on Communications (ICC 2007), Glasgow, Scotland, Jun. 2007, pp. 951 956. 3. M. Baldi, M. Bodrato, and F. Chiaraluce, "A new analysis of the McEliece cryptosystem based on QC-LDPC codes," in Security and Cryptography for Networks, ser. Lecture Notes in Computer Science. Springer Verlag, 2008, vol. 5229, pp. 246 262. 4. M. Baldi, F. Bambozzi, F. Chiaraluce, "On a Family of Circulant Matrices for Quasi-Cyclic Low-Density Generator Matrix Codes," IEEE Trans. on Information Theory, Vol. 57, No. 9, pp. 60526067, 2011. 5. M. Baldi, M. Bianchi, F. Chiaraluce, J. Rosenthal and D. Schipani, "Enhanced public key security for the McEliece cryptosystem" 2011. [Online]. Available: http://arxiv.org/abs/1108.2462 6. M. Baldi, M. Bianchi, and F. Chiaraluce. "Security and complexity of the McEliece cryptosystem based on QC-LDPC codes," IET Information Security, in press. [Online]. Available: http://arxiv.org/abs/1109.5827 7. M. Baldi, M. Bianchi, and F. Chiaraluce, "Optimization of the parity-check matrix density in QC-LDPC code-based McEliece cryptosystems," to be presented at the IEEE International Conference on Communications (ICC 2013) - Workshop on Information Security over Noisy and Lossy Communication Systems, Budapest, Hungary, Jun. 2013.

Using LDGM Codes and Sparse Syndromes to Achieve Digital Signatures

15

8. A. Becker, A. Joux, A. May, and A. Meurer, "Decoding random binary linear codes in 2n/20 : How 1 + 1 = 0 improves information set decoding," in EUROCRYPT 2012, ser. Lecture Notes in Computer Science. Springer Verlag, 2012. 9. D. J. Bernstein, T. Lange, and C. Peters, "Attacking and defending the McEliece cryptosystem," in Post-Quantum Cryptography, ser. Lecture Notes in Computer Science. Springer Verlag, 2008, vol. 5299, pp. 3146. 10. D. J. Bernstein, T. Lange, and C. Peters, "Smaller decoding exponents: ballcollision decoding," in CRYPTO 2011, ser. Lecture Notes in Computer Science. Springer Verlag, 2011, vol. 6841, pp. 743760. 11. F. Chabaud and J. Stern, "The cryptographic security of the syndrome decoding problem for rank distance codes," Proc. ASIACRYPT 1996, Kyongju, Korea, November 37, 1996, pp 368-381. 12. J. F. Cheng and R. J. McEliece, "Some high-rate near capacity codecs for the Gaussian channel," in Proc. 34th Allerton Conference on Communications, Control and Computing, Allerton, IL, Oct. 1996. 13. N. Courtois, M. Finiasz and N. Sendrier, "How to achieve a McEliece-based digital signature scheme," Proc. ASIACRYPT 2001, Vol. 2248 of LNCS, pp. 157-174, Springer, Heidelberg, 2001. 14. M. Finiasz and N. Sendrier, "Security bounds for the design of code-based cryptosystems," Proc. ASIACRYPT '09, Tokyo, Japan, Dec 610, 2009, pp. 88105. 15. M. Finiasz, "Parallel-CFS strengthening the CFS McEliece-based signature scheme," Proc. PQCrypto 2010, Darmstadt, Germany, May 25-28, 2010, pp. 6172. 16. J. Garcia-Frias and W. Zhong, "Approaching Shannon performance by iterative decoding of linear codes with low-density generator matrix," IEEE Commun. Lett., Vol. 7, No. 6, pp. 266268, Jun. 2003. 17. M. Gonz alez-L opez, F. J. V azquez-Ara ujo, L. Castedo, and J. Garcia-Frias, "Serially-concatenated low-density generator matrix (SCLDGM) codes for transmission over AWGN and Rayleigh fading channels," IEEE Trans. Wireless Commun., Vol. 6, No. 8, pp. 27532758, Aug. 2007. 18. G. Kabatianskii, E. Krouk and B. Smeets, "A digital signature scheme based on random error correcting codes," Proc. 6th IMA Int. Conf. on Cryptography and Coding, pp. 161-167, London, UK, 1997. 19. C. H. Lim and P. J. Lee, "On the length of hash-values for digital signature schemes," Proc. CISC '95, Seoul, Korea, Nov.1995, pp. 2931. 20. A. May, A. Meurer and E. Thomae, "Decoding random linear codes in O(20.054n )," Advances in Cryptology  ASIACRYPT 2011, Seoul, Korea, Dec 48, 2011, pp. 107124. 21. R. J. McEliece, "A public-key cryptosystem based on algebraic coding theory." DSN Progress Report, pp. 114116, 1978. 22. L. Minder and A. Sinclair, "The extended k-tree algorithm," Journal of Cryptology, Vol. 25, No. 2, pp. 349382, 2012. 23. R. Misoczki, J.-P. Tillich, N. Sendrier, and P. S. L. M. Barreto. (2012) MDPCMcEliece: New McEliece variants from moderate density parity-check codes. [Online]. Available: http://eprint.iacr.org/2012/409 24. C. Monico, J. Rosenthal, and A. Shokrollahi, "Using low density parity check codes in the McEliece cryptosystem," Proc. IEEE International Symposium on Information Theory (ISIT 2000), Sorrento, Italy, Jun. 2000, p. 215. 25. R. Niebuhr, P.-L. Cayrel and J. Buchmann, "Improving the efficiency of Generalized Birthday Attacks against certain structured cryptosystems," Proc. WCC 2011, Paris, France, Apr. 11-15, 2011.

16

M. Baldi, M. Bianchi, F. Chiaraluce, J. Rosenthal, D. Schipani

26. A. Otmani and J. P. Tillich, "An efficient attack on all concrete KKS proposals," Post-Quantum Cryptography (PQCrypto) 2011, Nov 29Dec 2, Taipei, Taiwan. LNCS, Springer-Verlag. 27. C. Peters, "Information-set decoding for linear codes over Fq ," in Post-Quantum Cryptography, Vol. 6061 of LNCS, Springer-Verlag Berlin Heidelberg, 2010, pp. 8194. 28. N. Sendrier, "Decoding one out of many". In B.-Y. Yang, editor, Post-Quantum Cryptography, ser. Lecture Notes in Computer Science. Springer Verlag, 2011, vol. 7071, pp. 5167. 29. J. Stern, "A method for finding codewords of small weight," in Coding Theory and Applications, Vol. 388 of LNCS, G. Cohen and J. Wolfmann, Eds., Springer, 1989, pp. 106113.


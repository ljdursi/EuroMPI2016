Incremental Sampling-based Algorithm for Minimum-violation Motion Planning
Luis I. Reyes Castro Pratik Chaudhari Jana T umov a Sertac Karaman Emilio Frazzoli Daniela Rus

arXiv:1305.1102v1 [cs.RO] 6 May 2013

Abstract-- This paper studies the problem of control strategy synthesis for dynamical systems with differential constraints to fulfill a given task specification while satisfying a set of safety rules. Particular attention is devoted to task specifications that become feasible only if a subset of the safety rules are violated. The proposed algorithm then computes a control law, that minimizes the level of unsafety for a trajectory that satisfies the given task specification. This problem is motivated by an autonomous car navigating an urban environment while following rules of the road such as "always travel in right lane" and "do not change lanes frequently". Ideas behind sampling based motion-planning algorithms, such as the Probabilistic Road Map (PRM) and Rapidly-exploring Random Tree (RRT), are employed to incrementally construct a finite concretization of the dynamics as a durational Kripke structure. In conjunction with this, a finite automaton that captures the safety rules is used in order to find an optimal trajectory that minimizes the violation of safety rules. It is shown that the proposed algorithm guarantees asymptotic optimality, i.e., almost-sure convergence to optimal solutions. Moreover, the algorithm is also demonstrated in computational experiments.

I. I NTRODUCTION From avoiding traffic jams in busy cities to helping the disabled and elderly on their daily commute, autonomous vehicles promise to revolutionize transportation. However, as they begin to transition from experimental projects like the DARPA Urban Challenge [1] to sharing road infrastructure with human drivers, we need to ensure that they obey the same rules that human drivers are subject to, e.g., rules of the road and safety rules. These rules, such as "always stay in the right lane" and "do not change lanes", can typically be expressed in formal languages such as Linear Temporal Logic (LTL) and deterministic -calculus. The general problem of finding optimal trajectories satisfying temporal logic tasks has been studied in a number of recent works such as [2][5]. In fact, as [6] points out, one of the main challenges of such approaches is the abstraction of continuous systems into equivalent finite transition systems for control synthesis. Moreover, the quality of these controllers depends upon the abstracted finite transition system, and there is no guarantee that a controller will be found (if one exists), i.e., these algorithms are not complete and cannot be applied to, for example, dynamically changing environments. On a related note, in the robotics literature, algorithms based on Probabilistic Road Maps (PRMs) and RapidlyThis work is supported in part by Michigan/AFRL Collaborative Center on Control Sciences, AFOSR grant FA 8650-07-2-3744, the US National Science Foundation, grant CNS-1016213, the National Research Foundation of Singapore, through the FM SMART IRG and the Nissan Motor Company.

exploring Random Trees (RRTs) have been used to synthesize dynamically-feasible trajectories. Algorithms such as PRM and RRT [7] are computationally efficient counterparts of these algorithms that guarantee almost sure asymptotic optimality of the returned trajectories. These algorithms have been primarily used for motion planning, and only recently, they have been adapted to handle complex task specifications given in temporal logics [8]. This work focuses on the case when a task specification is infeasible, unless some of the rules can be temporarily broken. Consider, for example, an autonomous car that must reach its final destination while abiding by the rules of the road, such as avoiding collisions with obstacles and staying in the right lane. However, it is more important to reach the destination than to stay in the correct lane. In fact, the latter rule is temporarily violated when, for instance, there is a blockage on the right lane, such as a disabled car. Motivated by these scenarios, we would like to systematically evaluate control strategies that not only pick the rules to be violated but also quantify the level of unsafety of the trajectory and minimize it. In this context, our work is closest in spirit to [9] and [10], and it extends our previous work in [11], where the problem of minimum-violation control synthesis for a pre-defined discrete transition system was considered. In this paper, using ideas from sampling-based motion planning algorithms, we concretize a continuous-time dynamical system into a finite durational Kripke structure, which captures the time duration required to transition between states. We leverage automata-based model checking approaches to construct a weighted automaton for a given set of prioritized safety rules, which enables us to quantify the level of unsafety of finite input words as the total weight of an accepting run. We next propose an algorithm, MVRRT (Minimum-Violation RRT ), that incrementally constructs the product of the Kripke structure and the weighted automaton and returns a trajectory of the dynamical system that, (i) minimizes the level of unsafety among all trajectories that satisfy the task, and (ii) minimizes a given cost function among all trajectories that satisfy (i). We prove that as the number of states of the Kripke structure goes to infinity, the solution converges to the optimal trajectory of the dynamical system that satisfies the same criteria. This paper is organized as follows. We introduce notation and preliminaries in Section II, followed by the problem formulation in Section III. Sections IV-V discuss details of the proposed algorithm. Simulations motivated by an autonomous car are discussed in Section VI. We conclude with directions for future work in Section VII.

II. P RELIMINARIES A. Durational Kripke Structures for Dynamical Systems Let  be a set of atomic propositions. The cardinality and the set of all subset of  are denoted by || and 2 , respectively. Let X  Rd and U  Rm be compact sets. Consider a dynamical system given by, x  (t) = f (x(t), u(t)), x(0) = xinit (1)

x(T ) = s2 , T = (s1 , s2 ) and there exists a T  [0, T ], such that Lc (x(t)) = Lc (s1 ), for all t  [0, T ], and Lc (x(t)) = Lc (s2 ), for all t  (T , T ] and, (iv) L(s) = Lc (s) for all states s  S . Roughly speaking, Lc (x(t)) changes its value at most once between two states. The following lemma easily follows from the definition above and connects trajectories of the dynamical system with traces of a durational Kripke structure. Lemma 3 For any trace r of a trace-inclusive Kripke structure K, there exists a trajectory of the dynamical system, say x : [0, T ]  X , such that, destutter(w(r)) = w(x). B. Finite Automata Definition 4 (Finite Automaton) A non-deterministic finite automaton (NFA) is a tuple A = (Q, qinit , , , F ), where  Q is a finite set of states;  qinit  Q is the initial state;   is an input alphabet;    Q	 Q is a non-deterministic transition relation;	F  Q is a set of accepting states. The semantics of finite automata are defined over finite words produced by durational Kripke structures (see Def. 1). In particular, in this work, the alphabet  is chosen to be 2  2 . A tuple  = (q1 , (1 , 2 ), q2 )   corresponds to a transition labeled with (1 , 2 )	2  2 from a state q1 to state q2 . A run  of a timed automaton over a finite word w = 0 , . . . , n is a sequence q0 , . . . , qn of states, such that q0 = qinit , and there exists a transition (qi , ( i , i+1 ), qi+1 )   , for all 0  i  n - 1. A word w is accepted if and only if there exists a run  = q0 , . . . , qn over w, such that qn  F . The language of an automaton A, denoted L(A), is the set of all words accepted by A. An automaton A is called non-blocking if, for all q  Q, and 1 , 2  , there exists a transition (q, ( 1 , 2 ), q )   . For each automaton A = (Q, qinit , , , F ) that is blocking, there exists a language equivalent non-blocking finite automaton A = (Q , qinit , ,  , F ), where Q = Q  {qnew }, and	=   {(q, ( 1 , 2 ), qnew ) |  , q  Q }. C. Finite LTL Finite automata can capture a large class of properties that are exhibited by traces of a transition system. However, some specification languages with similar expressive power, such as regular expressions or variants of Linear Temporal Logic (LTL) interpreted over finite runs, provide a more userfriendly means to express these properties. Please see [12], [13] for a thorough exposition to regular expressions and LTL. We demonstrate in Section VI, how desirable properties of the system, e.g., the rules of the road and safety rules, can be conveniently captured by a slight modification of Finite LTL (FLTL-X ) [14] without the next operator, a definition for which is given below. Definition 5 A FLTL-X formula  over the set of atomic propositions  is defined inductively as follows:

where xinit is the initial state. Trajectories of the states and controls are denoted by x : R0  X and u : R0  U respectively. In the sequel, we tacitly assume that the function f (, ) is Lipschitz continuous in both its arguments and u is Lebesgue measurable, to guarantee existence and uniqueness of solutions of Equation (1). For a set of atomic propositions , let Lc : X	2 be a function that maps each state to the atomic propositions that it satisfies. A timed word  over 2 is a finite sequence of elements of the set 2  R0 . In particular, a timed word produced by a trajectory x : [0, T ]  X is a finite sequence  (x) = ( 0 , d0 ), ( 1 , d1 ), . . . , ( n-1 , dn-1 ), ( n , dn ), where (i) 0 = Lc (x(0)) and d0 = 0, (ii) for all 1  i  n - 1, we have i = Lc (x(t)), for all t	[ti , ti+1 ), where t0 = 0 and ti = ti-1 + di , and (iii) n = n-1 = Lc (x(T )) and n i=0 dj = T . A word produced by a trajectory x : [0, T ]  X is a finite sequence w(x) = 0 , 1 , . . . , n-1 , n , such that  (x) = ( 0 , d0 ), ( 1 , d1 ), . . . , ( n-1 , dn-1 ), ( n , dn ) is the timed word produced by x. Definition 1 (Durational Kripke Structure) A durational Kripke structure is a tuple K = (S, sinit , R, , L, ), where  S is a finite set of states;	sinit  S is an initial state;  R  S  S is a deterministic transition relation;	 is a set of atomic propositions;   L : S  2 is a state labeling function;   : R  R0 is a function assigning a time duration to each transition. A trace of K is a finite sequence of states r = s0 , s1 , . . . , sn such that s0 = sinit and (si , si+1 )  R, for all 0  i < n. It produces a finite timed word  (r) = (L(s0 ), (s0 , s1 )), . . . , (L(sn-1 , (sn-1 , sn )) and a word w(r) = L(s0 ), L(s1 ), . . . , L(sn-1 ). Given a word w(r) = 0 , . . . , n , let I = {i0 , i1 , . . . , ik } be a set of indices, such that i0 = 0, ij = ij +1 = . . . = ij+1 -1 = ij+1 , for all 0  j  k - 1, and k = k+1 = . . . = n . Define destutter(w(r)) =
i0 , i1 , ik-1 , . . . , ik .

The following definition is used to concretize a continuous-time dynamical system defined in Eq. (1) into a durational Kripke structure. Definition 2 (Trace-Inclusive Kripke Structure) A durational Kripke structure K = (S, sinit , R, , L, ) is called trace-inclusive with respect to the dynamical system in Eq. (1) if (i) S  X , (ii) sinit = xinit , (iii) if (s1 , s2 )  R, there exists a trajectory x : [0, T ]  X such that x(0) = s1 ,

1) every pair of atomic propositions, (a, a )	  is a formula, 2) if 1 and 2 are formulas, then 1  2 , 1 , 1 U 2 , G 1 , and F 1 are each formulas, where  (negation) and  (disjunction) are standard Boolean connectives, and U, G, and F are temporal operators. Unlike the well-known LTL (see e.g., [13]), FLTL-X is interpreted over finite traces, as those generated by the durational Kripke structure from Def. 1. Informally, (a, a ) holds true on a trace 0 , 1 , . . . , n if a  0 , and a  1 . The formula 1 U 2 states that there is a future moment when formula 2 is true, and formula 1 is true at least until 2 is true. The formula G  states that formula  holds at all positions of a finite trace, and F  states that  holds at some future time instance. Just as LTL formulas can be algorithmically translated into automata over infinite words, FLTL formulas can be translated into finite automata [15]. D. Level of Unsafety Let K = (S, sinit , R, , L, ) be a durational Kripke structure. Let A = (Q, qinit , 2 , , F ) be the automaton for a safety rule with priority (A). In the sequel, we assume that the empty trace of K and the empty word always satisfy a safety rule given by any A, i.e., by convention, an empty trace does not violate any safety rules. Definition 6 (Level of unsafety for a safety rule) Let w = 0 , . . . , n be a word over 2 , define vanish(w, {i1 , . . . ik }) =
0 , . . . , i1 -1 , i1 +1 , . . . n ,

rules with priorities (, (w, i ) =

) are defined as, (w, Ai,j ),

Ai,j i

(w, ) = (w, 1 ), . . . , (w, n ) Level of unsafety for a trace r of K with respect to a set of rules with priorities is defined similarly. The standard lexicographic ordering for (r, ) is used to compare the level of unsafety for two traces r1 , r2 of K. III. P ROBLEM F ORMULATION For a compact set S  Rd , define sinit  S to be the initial state and a compact subset Sgoal	S as the goal region. Given the dynamical system in Eq. (1), define a task specification  to be, "traveling from sinit to Sgoal ". A trajectory of the dynamical system, x : [0, T ]  X is said to satisfy , if x(0) = sinit and x(T )	Sgoal . Similarly, a trace r = s0 , . . . , sn of a trace-inclusive Kripke structure satisfies	if s0 = sinit and sn  Sgoal . We tacitly assume that this task is feasible. Problem 8 Given a dynamical system as shown in Eq. (1), a task specification , a set of safety rules with priorities (, ) and a continuous function c(x) that maps a trajectory x of the dynamical system to a non-negative cost, find a finite trajectory x : [0, T ]  X producing a timed word  (x ) = ( 0 , d0 ) . . . ( n , dn ) such that, (i) x satisfies the task specification , (ii) x minimizes the level of unsafety, (w(x ), ), among all trajectories x that satisfy condition (i), (iii) x minimizes c(x ) among all trajectories x that satisfy conditions (i) and (ii). The solution of this problem as defined above exists if the task  is feasible. In this work, we restrict ourselves T to minimum-time cost functions, i.e., c(x) = 0 1dt. The algorithm described here however applies to a much wider class of functions including discounted cost as well as state and control based cost functions. In order to develop an algorithmic approach for Problem 8, we convert it to the following problem defined on a trace-inclusive durational Kripke structure. Problem 9 Given a durational Kripke structure K = (S, sinit , R, , L, ) that is trace-inclusive for the dynamical system in Eq. (1), a task specification , a set of safety rules with priorities (, ) and a cost function c(x), find a finite trace r = s0 , s1 , . . . , sn of K and a trajectory x : [0, T ]  X such that they satisfy the following conditions, (i) x satisfies , (ii) there exists a set {t0 , t1 , . . . , tn } such that t0 = 0, tn = T , si = x (ti ) and (si , si+1 ) = ti+1 -ti  0  i < n, (iii) r minimizes ( (r ), ) among all traces r of K that satisfy conditions (i) and (ii) and, (iv) x minimizes the cost function c(x ) among all trajectories x that satisfy (i) and (ii).

i.e., the finite sequence obtained from w by erasing states indexed with i1 , . . . , ik where {i1 , . . . , ik }  {0, . . . , n}. The level of unsafety (w, A) of w with respect to a safety rule expressed as a finite automaton A is the defined as follows. (w, A) =
I {0,...,n} | vanish(w,I )L(A)

min

(A).
i I

The level of unsafety for a trace r = s0 , . . . , sn+1 of a durational Kripke structure is then defined to be (r, A) =
I {0,...,n}|vanish(w(r ),I )L(A)

min

(si , si+1 ) (A).
i I

Consider a sequence of non-empty sets of safety rules  = (1 , . . . , n ) with each rule j  i , for all 1  i  n given in the form of a finite automaton Ai,j . A priority function : i	N assigns a priority to each rule Ai,j	i , for all 1  i  n. The ordered set  together with the priority function is called a set of safety rules with priorities (, ). We now extend the definition of the level of unsafety for a word w and a trace r to a set of safety rules with priorities (, ) as follows. Definition 7 (Level of unsafety for a set of rules) The level of unsafety of a word with respect to a set of rules i , (w, i ) and the level of unsafety with respect to a set of

IV. A LGORITHM This section describes an algorithm for finding minimumconstraint violation trajectories for a dynamical system. We first construct a weighted automaton whose weights are chosen such that the weight of an accepting run equals the level of unsafety of the input word. We then propose an algorithm, based on RRT , to incrementally construct the product of the durational Kripke structure and weighted automata representing safety rules. Roughly, the shortest path in the product uniquely maps to a trace of the Kripke structure that minimizes the level of unsafety. Let us note that the algorithm returns a trajectory that satisfies all rules and minimizes the cost function if it is possible to do so. A. Weighted product automaton First, we propose a method to augment each automaton Ai,j   with new transitions and weights, such that the resulting weighted automaton also accepts all words w that do not satisfy the rule Ai,j ; however, the weights are picked such that the weight of this accepting run over w determines the level of unsafety of w with respect to Ai,j (see Def. 10). Second, we combine all the weighted automata into a single weighted automaton A , using its weights to capture the level of unsafety of all words with respect to the given set of safety rules with priorities (, ) (see Def. 12). Third, we build a weighted product of the durational Kripke structure K and the automaton A (see Def. 14) with the weights corresponding to the level of unsafety of traces of K. We now proceed to describe each of these steps in detail and summarize the purpose of each construction in a lemma (see Def. 1014 and Lem. 1115). The material presented in this section is a slight modification of our earlier algorithm for finding a trace of a weighted transition system that minimizes the level of unsafety [11]. For the sake of brevity, proofs of these lemmas are omitted and can be found in [11]. Definition 10 (Automaton Ai,j ) For a non-blocking finite automaton Ai,j = (Qi,j , qinit,i,j , 2 , i,j , Fi,j ), a weighted finite automaton Ai,j = (Qi,j , q init,i,j , 2 ,	i,j , F i,j , W i,j ) is such that, Qi,j = Qi,j , q init,i,j = qinit,i,j ,  i,j = i,j  2 {(q, (,  ), q ) | q  Q and (,	)  2 }, F i,j = Fi,j and, W ) = 0 if   i,j (Ai,j ) if	 i,j \ i,j .

Definition 12 (Automaton A ) The weighted automaton A = (Q, q init , 2 , C, , F , W ) is defined as follows:  Q = Q1,1 . . .  . . . Q1,m1 . . .  . . . Qn,1 . . .  . . . Qn,mn ;  q init = (q init,1,1 , . . . , q init,n,mn );  (p, (,  ), p )   if  p = (q1,1 , . . . , qn,mn ), p = (q1,1 , . . . , qn,mn ), and  (qi,j , (,  ), qi,j )   i,j , for all i  {1, . . . , n}, j  {1, . . . mi }. Then also W ((p, (,  ), p )) = (x1 , . . . , xn ), where mi xi = j =1 W i,j (qi,j , (,  ), qi,j );  F = {(q1,1 , . . . , qn,mn ) | qi,j  F i,j , for all i  {1, . . . , n}, j	{1, . . . mi }} Lemma 13 Any word w over 2 is accepted by A and the weight of the shortest accepting run of A over w is equal to the level of unsafety (w, ). Definition 14 (Weighted product automaton P ) We build the weighted product automaton, P = K  A = (QP , qinit,P , P , FP , WP ) of the Kripke structure K = (S, sinit , R, , L, ) and the augmented automaton A = (Q, q init , 2 , , F , W ) as,	QP = S	Q is a set of states;  qinit,P = (sinit , q init ) is the initial state;  P  QP  QP is a non-deterministic transition relation, where ((s, q ), (s , q ))  P if (s, s )  R, and there exists a transition (q, (L(s), L(s )), q )   . Then also, WP (s, q ), (s , q ) = (x1  (s, s ), . . . , xn  (s, s )),


where (x1 , . . . , xn ) = W (q, L(s), L(s ), q ) and, FP = S  F is a set of accepting states.

The alphabet of the product automaton is trivial, and therefore omitted. A product automaton is in fact, a finite automaton extended with weights. A run of a product automaton is a sequence  = p0 , . . . , pn , such that p0 = qinit,P , and (pi , pi + 1)  P , for all 0  i < n and it is accepting if pn  F . The weight of a run WP () is the tuple obtained by component-wise sum of the weights associated with the transitions executed along the run. The shortest run over w is then a run  minimizing the weight WP () in the lexicographical ordering. Lemma 15 The shortest accepting run (in the lexicographical ordering with respect to WP ), p0 . . . pn of P from the state p0 = qinit,P to a state pn  FP projects onto a trace r = (p0 . . . pn ) of K that minimizes the level of unsafety. B. Incremental Weighted Product Automaton In this section, we incrementally construct the weighted product automaton (see Def. 14) and maintain the trace that minimizes the level of unsafety for a set of safety rules . A few preliminary procedures of the algorithm are as follows.

Lemma 11 If a word w over 2 is accepted by Ai,j , then, the weight of the shortest accepting run of Ai,j over w is equal to the level of unsafety (w, i,j ). A single weighted automaton A is created by combining all automata Ai,j , where Ai,j  i  . This captures the level of unsafety with respect to the whole set of safety rules with priorities (, ) through its weight function.

1) Sampling: The Sample procedure samples an independent, identically distributed state s from a uniform distribution supported over the bounded set S . 2) Nearest neighbors: The Near procedure returns the set, Snear (s) = {s | ||s - s||2	 (log n/n)
1/d

Algorithm 1: Create Product
1 2 3 4 5

; s  S}

where n = |S | and  is the constant in Thm. 16. 3) Steering: Given two states s, s , the Steer(s , s) procedure computes the pair (x, T ) where x : [0, T ]  X is a trajectory such that, (i) x(0) = s , (ii) x(T ) = s and, (iii) x minimizes the cost function c(x) = T . If a trajectory x is found, return true, else return false. 4) Connecting: For a state s  Snear , if Steer(s , s) returns true, for all nodes z = (s , q )	QP , if (z , (s, q )) is such that it can be in P (see Def. 14), the procedure Connect(s , s) adds the state z = (s, q ) to the set QP , adds (z , z ) to P and calculates WP (z , z ). If s  Sgoal and q  F , it adds (s, q ) to FP . 5) Updating costs: The procedure Update(s) updates the level of unsafety Ja (z ) and the cost Jt (s) from the root for a node z = (s, q ) as shown in Alg. 2 using the sets, Ssteer (s) = {s | s  Snear (s); Steer(s , s) returns true}, Zsteer (s) = {(s , q ) | s  Ssteer (s); (s , q )  QP }. 6) Rewiring: In order to ensure asymptotic optimality, the Rewire procedure recalculates the best parent Par(s ) for all states s  Snear (s) as shown in Alg. 3. The complexity of this procedure can be reduced by noting that s only needs to check if the new sample can be its parent by comparing costs Ja , Jt , otherwise its parent remains the same. Finally, Alg. 1 creates the weighted product automaton as defined in Def. 14 incrementally. It also maintains the best state z  = (s , q	)  FP . The trace r = s0 , s1 , . . . , sn of the Kripke structure K that minimizes the level of unsafety and is a solution to Problem 9 can then be obtained from z  by following Par(s ). Since K is trace-inclusive, the continuous-time trajectory x can be obtained by concatenating smaller trajectories. Let (xi , Ti ) be the trajectory returned by Steer(si , si+1 ) for all states si  r . The concatenated n-1 trajectory x : [0, T ]  X is such that T = i=0 Ti and i-1 xn (t + k=0 Tk ) = xi (t) for all i < n. V. A NALYSIS In this section, we analyze the convergence properties of Algorithm 1. In particular, we prove that the continuoustime trajectory xn given by the algorithm after n iterations converges to the solution of Problem 8 as the number of states in the durational Kripke structure Kn goes to infinity, with probability one. An analysis of the computational complexity of the algorithm is also carried out here. Due to lack of space, we only sketch the proofs. A. Asymptotic Optimality Theorem 16 The probability that Algorithm 1 returns a durational Kripke structure Kn and a trajectory of the dynamical system xn , that converges to the solution of

6

7 8 9

Input : n, S , A ; Output : Pn ; init P  ; QP  qP ; Ja (sinit )  0; Jt (sinit )  0; i  0; for i  n do // Sample new state s  Sample; // Connect neighbors for s  Near(s) do if Steer(s , s) then Connect(s , s); // Find best parent Par, Ja , Jt  Update(s); // Rewire neighbors P , Ja , Jt  Rewire(s);
init Pn  (QP , qP , P , FP , WP ); return Pn

10

11 12 13

Algorithm 2: Update(s, P )
1 2 3 4 5 6

for z = (s, q )  QP do WP (z , z ) + Ja (z ); Ja (z )  min Z   arg
z Zsteer z Zsteer

min

WP (z , z ) + Ja (z );

Jt (s)	min c(s , s) + Jt (s );
z Z

Par(z )  arg min c(s , s) + Jt (s );
z Z

return Par, Ja , Jt

Algorithm 3: Rewire(s, P )
1 2 3 4 5

for s  Ssteer (s) do if Steer(s, s ) then Connect(s, s ); Ja , Jt  Update(s ); return P

Problem 8 in the bounded variation norm sense, approaches one as the number of states in Kn tends to infinity, i.e., P { lim ||xn - x ||BV = 0} = 1
n

Proof: (Sketch) The prof primarily follows from the asymptotic optimality of the RRT algorithm (see Theorem 34 in [7]). Let x : [0, T ]  X be the solution of Problem 8 that satisfies the task  and minimizes the level of unsafety. For a large enough n, define a finite sequence of overlapping balls Bn = {Bn,1 , . . . , Bn,m } around the optimal trajectory x . The radius of these balls is set to be some fraction of  (log n/n)1/d such that any point in s	Bn,m can connect to any other point s  Bn,m+1 using the Steer(s, s ) function. It can then be shown that each ball in Bn contains at least one state of Kn with probability one. In such a case, there exists a trace rn = s0 , s1 , . . . , sn of Kn such that every state si lies in some ball Bn,m . Also, for a large enough n, the level of unsafety of rn , (rn , ) is equal to the level of unsafety of the word generated by the trajectory x , ( (x ), ), i.e., MVRRT returns the trace with the minimum level of unsafety among all traces of the Kripke

structure K satisfying the task . Finally, it can be shown that the output of the algorithm, trajectory xn converges to the optimal solution x almost surely as n  .
(S ) 1 , where (S ) is In this proof,  > 2 2 + d d the Lebesgue measure of the set S , d is the volume of the unit ball in S which is of dimensionality d. The following lemma is an immediate consequence of Theorem 16 and the continuity of the cost function c(x). 1/d 1/d

Lemma 17 The cost of the solution converges to the optimal cost, c = c(x ), as the number of samples approaches infinity, almost surely, i.e, P { lim c(xn ) = c } = 1.
n

Fig. 1: Partitions of the working domain S . The transition from s1 to s2 is labeled with, for example, {(rl, ll), (rl, dir), (rl, dotted)}.

B. Computational Complexity Let us now comment on the computational complexity of MVRRT . Lemma 18 The expected computational complexity of MVRRT is O(m2 log n) per iteration where n is the number of states in the durational Kripke structure K and m is the number of states of the automaton A (see Def. 12). This follows from an analysis of Algorithm 1. Note that there are an expected O(log n) samples in a ball of radius	(log n/n)1/d . The procedure Steer is called on an expected O(log n) samples while because the automaton A is non-deterministic, the procedure Connect adds at most m2 new states in the product automaton per sample. The procedure Update requires at most O(m2 log n) time call. The Rewire procedure simply updates the parents of the O(log n) neighboring samples which take O(m2 log n) time. In total, the computational complexity of MVRRT is O(m2 log n) per iteration. VI. C OMPUTATIONAL E XPERIMENTS In this section, we consider an autonomous car modeled as a Dubin's vehicle in a road-like environment along with roadsafety rules and we evaluate the performance of MVRRT in a number of different situations. A. Experimental Setup Consider a Dubin's car, i.e., a curvature-constrained vehicle with dynamics given by the differential equations, x  (t) = v cos (t) y  (t) = v sin (t) (t) = u(t)  (2)

the atomic propositions capture, (i) whether the vehicle is present in the right lane of the road, the left lane of the road, or the sidewalk, (ii) whether the vehicle is heading in the correct direction or not, and (iii) whether the center line is dotted or solid. We therefore partition the working domain S into compact non-empty subsets Sobs , Ssw , Srl , and Sll , where Sobs is the union of regions occupied with obstacles, Ssw represents the sidewalk and Srl , Sll are the right and the left lanes, respectively. In the presence of no obstacles, Sobs is empty. These partitions are illustrated in Fig. 1. Based on this partitioning and the current state of the Dubin's vehicle, we define the set of atomic propositions as,  = {sw, rl, ll, dir, dotted, solid}. For a state s  S in the trace-inclusive durational Kripke structure K, the proposition sw is true if s  Ssw . Similarly, the atomic proposition rl is true if s	Srl , and ll is true if s  Sll . The propositions rl and ll cannot both be true at the same time. The proposition dir models whether the heading of the car is in the correct direction or not, i.e., dir is true if the state s is such that it is heading forwards and rl is true. Note that dir can be calculated using the state s and the geometry of the road. Furthermore, one of the atomic propositions dotted and solid is always true, depending on the lane on which the vehicle's state is located. Note that obstacles are not considered while constructing  since we do not desire a trajectory that goes over an obstacle in any case. Hence, the Steer procedure in Section IV returns false if any state along the trajectory lies in Sobs . This change does not affect the correctness and the overall complexity of MVRRT . B. Safety Rules Given a task	such as finding a trajectory from sinit to the goal region Sgoal , we require the vehicle to follow the following rules: (i) do not travel on the sidewalk (sidewalk rule), (ii) do not cross the solid center line (hard lane changing), (iii.a) always travel in the correct direction (direction rule), and (iii.b) do not cross the dotted center line (soft lane changing). We describe the rules with the following FLTL formulas and corresponding finite automata in Fig. 2. Note that we use 2-tuples of atomic propositions from  as the alphabet for

The state of the system is the vector [ x, y, ]T , and the input is u(t), where |u(t)|	1 for all t  0. The vehicle is assumed to travel at a constant speed v . As shown in [16], time-optimal trajectories for this system in an obstacle-free environment can be easily calculated. Each state of the Dubin's vehicle is labeled with the set of atomic propositions that hold true in that state. Namely,

both formulas and the automata, so that we can specify not only properties of individual states, but also of transitions. The first component of the tuple captures the atomic proposition true in the starting state of the transition; the second component represents the atomic proposition of the ending state. (i) Sidewalk: Do not take a transition that ends at a state labeled sw. (, sw) 1,1 = G
2

(ii) Hard lane change: Do not take any transition that changes lanes and crosses a solid center line. 2,1 = G  (rl, solid)  (rl, ll)  (ll, solid)  (ll, rl) (iii.a) Direction: Do not take any transition that leads to motion in the wrong direction. 3,1 = G
2

Fig. 3: MVRRT tree after 40 sec. on an example without any safety rules. The shortest trajectory shown in red to the goal region avoids obstacles but uses the sidewalk.

(, dir)

(iii.b) Soft lane change: Do not take any transition that changes lanes and crosses a dotted center line. 3,2 = G  (rl, dotted)  (rl, ll)  (ll, dotted)  (ll, rl) The finite automata for rules (i)-(iii.b) are all of the same form (see Fig. 2). q1
( , )

Fig. 2: Direction rule. For brevity of presentation, there is only one transition depicted representing in fact all the transitions, where (i) ,  2 , is arbitrary and dir  , (ii) ,  2 , such that rl	and dotted, ll	, or ll  and dotted, rl  , (iii) ,  2 , such that rl  and solid, ll  , or ll  and solid, rl  , and (iv) ,  2 , is arbitrary and sw

While it is quite natural to disobey the direction and the soft lane change rules, the solid lane should not be crossed and especially, the sidewalk should be entered only if there is no other way to reach the target region. This gives three different priority classes (1 , 2 , 3 ), ) = (({1,1 }, {2,1 }, {3,1 , 3,2 }), ),

where (1,1 ) = (2,1 ) = (3,1 ) = 1 and (3,2 ) = 10. Note that costs for 2,1 and 3,2 are incurred only once per crossing and do not depend upon the duration of the transition. Within the third class, we put higher priority on the soft lane change rule to avoid frequent lane switching, for instance in case two obstacles are very closed to each other and it is not advantageous to come back to the right lane for a short period of time, e.g., see Fig. 4. C. Examples MVRRT was implemented in C++ on a 2.2GHz processor with 4GB of RAM for the experiments in this section. We demonstrate the performance of MVRRT in a number of different scenarios in the same environment to be able to quantitatively compare the performance. In Fig. 4, the

Dubin's vehicle starts from the lower right hand corner while the goal region marked in green is located in the lower left hand corner. Light grey denotes the right and left lanes, Srl and Sll . A sidewalk Ssw is depicted in dark grey. The dotted center line is denoted as a thin yellow line while solid center lines are marked using double lines. Stationary obstacles in this environment are shown in red. a) Case 1: First, we consider a scenario without any safety or road rules. The MVRRT algorithm then simply aims to find the shortest obstacle-free trajectory from the initial state to the goal region. Note, that in this case, MVRRT performs the same steps as the RRT algorithm. The solution computed after 40 seconds has a cost of 88.3 and is illustrated in Fig. 3 together with the adjoining tree. b) Case 2: Next, we introduce the sidewalk rule 1,1 and the direction rule 3,1 . Without any penalty on frequent lane changing, the algorithm gives a trajectory that goes back into the right lane after passing the first obstacle. It has to cross the center line again in order to pass the second obstacle and reach the goal region. Fig 4a depicts the solution obtained after 60 seconds, this has a cost of 122.3 along with a level of unsafety of 46.4 for breaking 3,1 . Upon introducing the rule 3,2 , the vehicle does not go back into the right lane after passing the first obstacle. Figure 4b shows this solution with a level of unsafety of 84.1 for breaking both 3,1 and 3,2 whereas the level of unsafety in this case for the trajectory in Fig. 4a is 87.4. In Fig. 4c, we only have the sidewalk and direction rules. Since the road is completely blocked, MVRRT is forced to break the sidewalk rule resulting in a level of unsafety of 13.9 47.3 for rules 1,1 and 3,1 respectively. c) Case 3: Fig 5a shows a run for the sidewalk, direction and the soft lane changing rule after 60 secs. of execution with a level of unsafety of (0, 0, 28.3). As shown in Fig. 5b, if instead executed for 120 secs., the algorithm converges to a solution which has a much higher cost (215.8) but a significantly lower level of unsafety (0, 0, 1.6) because it only breaks the direction rule slightly when it turns into the lane. This thus demonstrates the incrementality and anytime nature of the algorithm. d) Case 4: In our last example, we introduce hard and soft lane changing rules along with sidewalk and direction rules. After 15 secs., MVRRT returns the solution shown

(a)

(a)

(b)

(b)

(c) (c)

(d)

Fig. 4: Fig. 4a shows the solution after 60 secs. for the sidewalk and direction rules. Upon introducing the soft lane changing rule in Fig. 4b, the vehicle does not return to the right lane after passing the first obstacle. Since the road is completely blocked in Fig. 4c, breaking the sidewalk rule is unavoidable

in Fig. 5c, which breaks the hard lane changing rule twice, thereby incuring a level of unsafety of (0, 2, 48.1) for the three rules. On the other hand, after about 300 secs., the solution converges to the trajectory shown in Fig. 5d which breaks the hard lane changing rule only once, this has a level of unsafety of (0, 1, 25.17). VII. C ONCLUSIONS Motivated by problems in autonomous vehicle navigation, this paper considered the problem of synthesizing minimumviolation control strategies for continuous dynamical systems that are subject to a set of safety rules and satisfy a given task specification. In particular, we focus on the case when the task is infeasible given the set of rules. We leverage ideas from sampling-based motion-planning algorithms and automata-based model checking approaches to propose an incremental algorithm to generate a trajectory of the dynamical system that picks which safety rules to violate while at the same time, it also minimizes the level of unsafety. Future directions for work include investigation of timedLTL formulae, modeling rules such as yielding at cross-roads as well as an implementation of the proposed algorithm on an experimental autonomous vehicle. R EFERENCES
[1] John Leonard, Jonathan How, Seth Teller, Mitch Berger, Stefan Campbell, Gaston Fiore, Luke Fletcher, Emilio Frazzoli, Aalbert Huang, Sertac Karaman, et al. A perception-driven autonomous urban vehicle. Journal of Field Robotics, 25(10):727774, 2008. [2] Xu Chu Ding, Stephen L Smith, Calin Belta, and Daniela Rus. MDP optimal control under temporal logic constraints. In Proc. of IEEE Conf. on Decision and Control and European Control Conference (CDC-ECC), pages 532538, 2011. [3] Paulo Tabuada and George J Pappas. Linear time logic control of discrete-time linear systems. IEEE Transactions on Automatic Control, 51(12):18621877, 2006.

Fig. 5: Fig. 5a and 5b show the solution of MVRRT after 60 and 120 secs. respectively, with the sidewalk, direction and soft lane changing rules. Note that the algorithm converges to a long trajectory which does not break any rules. Fig. 5c shows a solution after 20 secs. which breaks the hard lane changing rule twice. After 120 secs., the algorithm converges to the solution shown in Fig. 5d, which features only one hard lane change and three soft lane changes.
[4] Stephen L Smith, Jana Tumova, Calin Belta, and Daniela Rus. Optimal path planning for surveillance with temporal-logic constraints. The International Journal of Robotics Research, 30(14):16951708, 2011. [5] Alphan Ulusoy, Stephen L Smith, Xu Chu Ding, and Calin Belta. Robust multi-robot optimal path planning with temporal logic constraints. In Proc. of IEEE Int. Conf. on Robotics and Automation (ICRA), pages 46934698, 2012. [6] Tichakorn Wongpiromsarn, Ufuk Topcu, and Richard M Murray. Receding horizon control for temporal logic specifications. In Proc. of the 13th ACM Int. Conf. on Hybrid systems: Computation and Control, pages 101110, 2010. [7] Sertac Karaman and Emilio Frazzoli. Sampling-based algorithms for optimal motion planning. International Journal of Robotics Research, 30(7):846894, 2011. [8] Sertac Karaman and Emilio Frazzoli. Sampling-based algorithms for optimal motion planning with deterministic -calculus specifications. In Proc. of American Control Conference (ACC), 2012. [9] Vasumathi Raman and Hadas Kress-Gazit. Automated feedback for unachievable high-level robot behaviors. In Proc. of IEEE Int. Conf. on Robotics and Automation (ICRA), pages 51565162, 2012. [10] Kris Hauser. The minimum constraint removal problem with three robotics applications. In Proc. of Workshop on the Algorithmic Foundations of Robotics (WAFR), 2012. [11] Jana Tumova, Gavin C. Hall, Sertac Karaman, Emilio Frazzoli, and Daniela Rus. Least-violating control strategy synthesis with safety rules. In Proceedings of the 16th ACM international conference on Hybrid systems: computation and control. ACM, 2013. To appear. [12] Michael Sipser. Introduction to the Theory of Computation. Course Technology, 3rd edition, 2012. [13] Christel Baier and Joost-Pieter Katoen. Principles of Model Checking. MIT Press, 2008. [14] Zohar Manna and Amir Pnueli. Temporal Verification of Reactive Systems: Safety. Springer, 1995. [15] Elsa L. Gunter and Doron Peled. Temporal debugging for concurrent systems. In International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS), pages 431444. Springer-Verlag, 2002. [16] Lester E Dubins. On curves of minimal length with a constraint on average curvature, and with prescribed initial and terminal positions and tangents. American Journal of Mathematics, pages 497516, 1957.

